#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Blur::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Blur::Blur_shardClusterList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardClusterList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardClusterList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardClusterList_result;
use base qw(Class::Accessor);
Blur::Blur_shardClusterList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardClusterList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size140 = 0;
          $self->{success} = [];
          my $_etype143 = 0;
          $xfer += $input->readListBegin(\$_etype143, \$_size140);
          for (my $_i144 = 0; $_i144 < $_size140; ++$_i144)
          {
            my $elem145 = undef;
            $xfer += $input->readString(\$elem145);
            push(@{$self->{success}},$elem145);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardClusterList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter146 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter146);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerList_args;
use base qw(Class::Accessor);
Blur::Blur_shardServerList_args->mk_accessors( qw( cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerList_args');
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 1);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerList_result;
use base qw(Class::Accessor);
Blur::Blur_shardServerList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size147 = 0;
          $self->{success} = [];
          my $_etype150 = 0;
          $xfer += $input->readListBegin(\$_etype150, \$_size147);
          for (my $_i151 = 0; $_i151 < $_size147; ++$_i151)
          {
            my $elem152 = undef;
            $xfer += $input->readString(\$elem152);
            push(@{$self->{success}},$elem152);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter153 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter153);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_controllerServerList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_controllerServerList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_controllerServerList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_controllerServerList_result;
use base qw(Class::Accessor);
Blur::Blur_controllerServerList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_controllerServerList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size154 = 0;
          $self->{success} = [];
          my $_etype157 = 0;
          $xfer += $input->readListBegin(\$_etype157, \$_size154);
          for (my $_i158 = 0; $_i158 < $_size154; ++$_i158)
          {
            my $elem159 = undef;
            $xfer += $input->readString(\$elem159);
            push(@{$self->{success}},$elem159);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_controllerServerList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter160 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter160);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayout_args;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayout_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayout_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayout_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayout_result;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayout_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayout_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size161 = 0;
          $self->{success} = {};
          my $_ktype162 = 0;
          my $_vtype163 = 0;
          $xfer += $input->readMapBegin(\$_ktype162, \$_vtype163, \$_size161);
          for (my $_i165 = 0; $_i165 < $_size161; ++$_i165)
          {
            my $key166 = '';
            my $val167 = '';
            $xfer += $input->readString(\$key166);
            $xfer += $input->readString(\$val167);
            $self->{success}->{$key166} = $val167;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayout_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter168,$viter169) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter168);
          $xfer += $output->writeString($viter169);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableList_result;
use base qw(Class::Accessor);
Blur::Blur_tableList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size170 = 0;
          $self->{success} = [];
          my $_etype173 = 0;
          $xfer += $input->readListBegin(\$_etype173, \$_size170);
          for (my $_i174 = 0; $_i174 < $_size170; ++$_i174)
          {
            my $elem175 = undef;
            $xfer += $input->readString(\$elem175);
            push(@{$self->{success}},$elem175);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter176 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter176);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableListByCluster_args;
use base qw(Class::Accessor);
Blur::Blur_tableListByCluster_args->mk_accessors( qw( cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableListByCluster_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableListByCluster_args');
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 1);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableListByCluster_result;
use base qw(Class::Accessor);
Blur::Blur_tableListByCluster_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableListByCluster_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size177 = 0;
          $self->{success} = [];
          my $_etype180 = 0;
          $xfer += $input->readListBegin(\$_etype180, \$_size177);
          for (my $_i181 = 0; $_i181 < $_size177; ++$_i181)
          {
            my $elem182 = undef;
            $xfer += $input->readString(\$elem182);
            push(@{$self->{success}},$elem182);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableListByCluster_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter183 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter183);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_describe_args;
use base qw(Class::Accessor);
Blur::Blur_describe_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_describe_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_describe_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_describe_result;
use base qw(Class::Accessor);
Blur::Blur_describe_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_describe_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::TableDescriptor();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_describe_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_query_args;
use base qw(Class::Accessor);
Blur::Blur_query_args->mk_accessors( qw( table blurQuery ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{blurQuery} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{blurQuery}) {
      $self->{blurQuery} = $vals->{blurQuery};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{blurQuery} = new Blur::BlurQuery();
        $xfer += $self->{blurQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_query_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blurQuery}) {
    $xfer += $output->writeFieldBegin('blurQuery', TType::STRUCT, 2);
    $xfer += $self->{blurQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_query_result;
use base qw(Class::Accessor);
Blur::Blur_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::BlurResults();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_cancelQuery_args;
use base qw(Class::Accessor);
Blur::Blur_cancelQuery_args->mk_accessors( qw( table uuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{uuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_cancelQuery_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_cancelQuery_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::I64, 2);
    $xfer += $output->writeI64($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_cancelQuery_result;
use base qw(Class::Accessor);
Blur::Blur_cancelQuery_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_cancelQuery_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_cancelQuery_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_currentQueries_args;
use base qw(Class::Accessor);
Blur::Blur_currentQueries_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_currentQueries_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_currentQueries_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_currentQueries_result;
use base qw(Class::Accessor);
Blur::Blur_currentQueries_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_currentQueries_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size184 = 0;
          $self->{success} = [];
          my $_etype187 = 0;
          $xfer += $input->readListBegin(\$_etype187, \$_size184);
          for (my $_i188 = 0; $_i188 < $_size184; ++$_i188)
          {
            my $elem189 = undef;
            $elem189 = new Blur::BlurQueryStatus();
            $xfer += $elem189->read($input);
            push(@{$self->{success}},$elem189);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_currentQueries_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter190 (@{$self->{success}}) 
        {
          $xfer += ${iter190}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusIdList_args;
use base qw(Class::Accessor);
Blur::Blur_queryStatusIdList_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusIdList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusIdList_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusIdList_result;
use base qw(Class::Accessor);
Blur::Blur_queryStatusIdList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusIdList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size191 = 0;
          $self->{success} = [];
          my $_etype194 = 0;
          $xfer += $input->readListBegin(\$_etype194, \$_size191);
          for (my $_i195 = 0; $_i195 < $_size191; ++$_i195)
          {
            my $elem196 = undef;
            $xfer += $input->readI64(\$elem196);
            push(@{$self->{success}},$elem196);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusIdList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::I64, scalar(@{$self->{success}}));
      {
        foreach my $iter197 (@{$self->{success}}) 
        {
          $xfer += $output->writeI64($iter197);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusById_args;
use base qw(Class::Accessor);
Blur::Blur_queryStatusById_args->mk_accessors( qw( table uuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{uuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusById_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusById_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::I64, 2);
    $xfer += $output->writeI64($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusById_result;
use base qw(Class::Accessor);
Blur::Blur_queryStatusById_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusById_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::BlurQueryStatus();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusById_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_schema_args;
use base qw(Class::Accessor);
Blur::Blur_schema_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_schema_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_schema_result;
use base qw(Class::Accessor);
Blur::Blur_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::Schema();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_getTableStats_args;
use base qw(Class::Accessor);
Blur::Blur_getTableStats_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_getTableStats_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_getTableStats_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_getTableStats_result;
use base qw(Class::Accessor);
Blur::Blur_getTableStats_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_getTableStats_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::TableStats();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_getTableStats_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_terms_args;
use base qw(Class::Accessor);
Blur::Blur_terms_args->mk_accessors( qw( table columnFamily columnName startWith size ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnFamily} = undef;
  $self->{columnName} = undef;
  $self->{startWith} = undef;
  $self->{size} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnFamily}) {
      $self->{columnFamily} = $vals->{columnFamily};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
    if (defined $vals->{startWith}) {
      $self->{startWith} = $vals->{startWith};
    }
    if (defined $vals->{size}) {
      $self->{size} = $vals->{size};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_terms_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnFamily});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startWith});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_terms_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamily}) {
    $xfer += $output->writeFieldBegin('columnFamily', TType::STRING, 2);
    $xfer += $output->writeString($self->{columnFamily});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 3);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startWith}) {
    $xfer += $output->writeFieldBegin('startWith', TType::STRING, 4);
    $xfer += $output->writeString($self->{startWith});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{size}) {
    $xfer += $output->writeFieldBegin('size', TType::I16, 5);
    $xfer += $output->writeI16($self->{size});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_terms_result;
use base qw(Class::Accessor);
Blur::Blur_terms_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_terms_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size198 = 0;
          $self->{success} = [];
          my $_etype201 = 0;
          $xfer += $input->readListBegin(\$_etype201, \$_size198);
          for (my $_i202 = 0; $_i202 < $_size198; ++$_i202)
          {
            my $elem203 = undef;
            $xfer += $input->readString(\$elem203);
            push(@{$self->{success}},$elem203);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_terms_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter204 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter204);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_recordFrequency_args;
use base qw(Class::Accessor);
Blur::Blur_recordFrequency_args->mk_accessors( qw( table columnFamily columnName value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnFamily} = undef;
  $self->{columnName} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnFamily}) {
      $self->{columnFamily} = $vals->{columnFamily};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_recordFrequency_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnFamily});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_recordFrequency_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamily}) {
    $xfer += $output->writeFieldBegin('columnFamily', TType::STRING, 2);
    $xfer += $output->writeString($self->{columnFamily});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 3);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_recordFrequency_result;
use base qw(Class::Accessor);
Blur::Blur_recordFrequency_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_recordFrequency_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_recordFrequency_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_fetchRow_args;
use base qw(Class::Accessor);
Blur::Blur_fetchRow_args->mk_accessors( qw( table selector ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{selector} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{selector}) {
      $self->{selector} = $vals->{selector};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_fetchRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{selector} = new Blur::Selector();
        $xfer += $self->{selector}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_fetchRow_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{selector}) {
    $xfer += $output->writeFieldBegin('selector', TType::STRUCT, 2);
    $xfer += $self->{selector}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_fetchRow_result;
use base qw(Class::Accessor);
Blur::Blur_fetchRow_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_fetchRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::FetchResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_fetchRow_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutate_args;
use base qw(Class::Accessor);
Blur::Blur_mutate_args->mk_accessors( qw( mutation ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutation} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutation}) {
      $self->{mutation} = $vals->{mutation};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutation} = new Blur::RowMutation();
        $xfer += $self->{mutation}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutate_args');
  if (defined $self->{mutation}) {
    $xfer += $output->writeFieldBegin('mutation', TType::STRUCT, 1);
    $xfer += $self->{mutation}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutate_result;
use base qw(Class::Accessor);
Blur::Blur_mutate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutate_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutateBatch_args;
use base qw(Class::Accessor);
Blur::Blur_mutateBatch_args->mk_accessors( qw( mutations ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutations} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutations}) {
      $self->{mutations} = $vals->{mutations};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutateBatch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size205 = 0;
          $self->{mutations} = [];
          my $_etype208 = 0;
          $xfer += $input->readListBegin(\$_etype208, \$_size205);
          for (my $_i209 = 0; $_i209 < $_size205; ++$_i209)
          {
            my $elem210 = undef;
            $elem210 = new Blur::RowMutation();
            $xfer += $elem210->read($input);
            push(@{$self->{mutations}},$elem210);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutateBatch_args');
  if (defined $self->{mutations}) {
    $xfer += $output->writeFieldBegin('mutations', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{mutations}}));
      {
        foreach my $iter211 (@{$self->{mutations}}) 
        {
          $xfer += ${iter211}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutateBatch_result;
use base qw(Class::Accessor);
Blur::Blur_mutateBatch_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutateBatch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutateBatch_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_createTable_args;
use base qw(Class::Accessor);
Blur::Blur_createTable_args->mk_accessors( qw( tableDescriptor ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableDescriptor} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableDescriptor}) {
      $self->{tableDescriptor} = $vals->{tableDescriptor};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_createTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tableDescriptor} = new Blur::TableDescriptor();
        $xfer += $self->{tableDescriptor}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_createTable_args');
  if (defined $self->{tableDescriptor}) {
    $xfer += $output->writeFieldBegin('tableDescriptor', TType::STRUCT, 1);
    $xfer += $self->{tableDescriptor}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_createTable_result;
use base qw(Class::Accessor);
Blur::Blur_createTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_createTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_createTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_enableTable_args;
use base qw(Class::Accessor);
Blur::Blur_enableTable_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_enableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_enableTable_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_enableTable_result;
use base qw(Class::Accessor);
Blur::Blur_enableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_enableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_enableTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_disableTable_args;
use base qw(Class::Accessor);
Blur::Blur_disableTable_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_disableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_disableTable_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_disableTable_result;
use base qw(Class::Accessor);
Blur::Blur_disableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_disableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_disableTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_removeTable_args;
use base qw(Class::Accessor);
Blur::Blur_removeTable_args->mk_accessors( qw( table deleteIndexFiles ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{deleteIndexFiles} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{deleteIndexFiles}) {
      $self->{deleteIndexFiles} = $vals->{deleteIndexFiles};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_removeTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteIndexFiles});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_removeTable_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteIndexFiles}) {
    $xfer += $output->writeFieldBegin('deleteIndexFiles', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{deleteIndexFiles});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_removeTable_result;
use base qw(Class::Accessor);
Blur::Blur_removeTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_removeTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_removeTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_optimize_args;
use base qw(Class::Accessor);
Blur::Blur_optimize_args->mk_accessors( qw( table numberOfSegmentsPerShard ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{numberOfSegmentsPerShard} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{numberOfSegmentsPerShard}) {
      $self->{numberOfSegmentsPerShard} = $vals->{numberOfSegmentsPerShard};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_optimize_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{numberOfSegmentsPerShard});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_optimize_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numberOfSegmentsPerShard}) {
    $xfer += $output->writeFieldBegin('numberOfSegmentsPerShard', TType::I32, 2);
    $xfer += $output->writeI32($self->{numberOfSegmentsPerShard});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_optimize_result;
use base qw(Class::Accessor);
Blur::Blur_optimize_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_optimize_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_optimize_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_isInSafeMode_args;
use base qw(Class::Accessor);
Blur::Blur_isInSafeMode_args->mk_accessors( qw( cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_isInSafeMode_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_isInSafeMode_args');
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 1);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_isInSafeMode_result;
use base qw(Class::Accessor);
Blur::Blur_isInSafeMode_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_isInSafeMode_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_isInSafeMode_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurIf;

use strict;


sub shardClusterList{
  my $self = shift;

  die 'implement interface';
}

sub shardServerList{
  my $self = shift;
  my $cluster = shift;

  die 'implement interface';
}

sub controllerServerList{
  my $self = shift;

  die 'implement interface';
}

sub shardServerLayout{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub tableList{
  my $self = shift;

  die 'implement interface';
}

sub tableListByCluster{
  my $self = shift;
  my $cluster = shift;

  die 'implement interface';
}

sub describe{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub query{
  my $self = shift;
  my $table = shift;
  my $blurQuery = shift;

  die 'implement interface';
}

sub cancelQuery{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  die 'implement interface';
}

sub currentQueries{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub queryStatusIdList{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub queryStatusById{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  die 'implement interface';
}

sub schema{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub getTableStats{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub terms{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $startWith = shift;
  my $size = shift;

  die 'implement interface';
}

sub recordFrequency{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $value = shift;

  die 'implement interface';
}

sub fetchRow{
  my $self = shift;
  my $table = shift;
  my $selector = shift;

  die 'implement interface';
}

sub mutate{
  my $self = shift;
  my $mutation = shift;

  die 'implement interface';
}

sub mutateBatch{
  my $self = shift;
  my $mutations = shift;

  die 'implement interface';
}

sub createTable{
  my $self = shift;
  my $tableDescriptor = shift;

  die 'implement interface';
}

sub enableTable{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub disableTable{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub removeTable{
  my $self = shift;
  my $table = shift;
  my $deleteIndexFiles = shift;

  die 'implement interface';
}

sub optimize{
  my $self = shift;
  my $table = shift;
  my $numberOfSegmentsPerShard = shift;

  die 'implement interface';
}

sub isInSafeMode{
  my $self = shift;
  my $cluster = shift;

  die 'implement interface';
}

package Blur::BlurRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub shardClusterList{
  my ($self, $request) = @_;

  return $self->{impl}->shardClusterList();
}

sub shardServerList{
  my ($self, $request) = @_;

  my $cluster = ($request->{'cluster'}) ? $request->{'cluster'} : undef;
  return $self->{impl}->shardServerList($cluster);
}

sub controllerServerList{
  my ($self, $request) = @_;

  return $self->{impl}->controllerServerList();
}

sub shardServerLayout{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->shardServerLayout($table);
}

sub tableList{
  my ($self, $request) = @_;

  return $self->{impl}->tableList();
}

sub tableListByCluster{
  my ($self, $request) = @_;

  my $cluster = ($request->{'cluster'}) ? $request->{'cluster'} : undef;
  return $self->{impl}->tableListByCluster($cluster);
}

sub describe{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->describe($table);
}

sub query{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $blurQuery = ($request->{'blurQuery'}) ? $request->{'blurQuery'} : undef;
  return $self->{impl}->query($table, $blurQuery);
}

sub cancelQuery{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $uuid = ($request->{'uuid'}) ? $request->{'uuid'} : undef;
  return $self->{impl}->cancelQuery($table, $uuid);
}

sub currentQueries{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->currentQueries($table);
}

sub queryStatusIdList{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->queryStatusIdList($table);
}

sub queryStatusById{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $uuid = ($request->{'uuid'}) ? $request->{'uuid'} : undef;
  return $self->{impl}->queryStatusById($table, $uuid);
}

sub schema{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->schema($table);
}

sub getTableStats{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->getTableStats($table);
}

sub terms{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $columnFamily = ($request->{'columnFamily'}) ? $request->{'columnFamily'} : undef;
  my $columnName = ($request->{'columnName'}) ? $request->{'columnName'} : undef;
  my $startWith = ($request->{'startWith'}) ? $request->{'startWith'} : undef;
  my $size = ($request->{'size'}) ? $request->{'size'} : undef;
  return $self->{impl}->terms($table, $columnFamily, $columnName, $startWith, $size);
}

sub recordFrequency{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $columnFamily = ($request->{'columnFamily'}) ? $request->{'columnFamily'} : undef;
  my $columnName = ($request->{'columnName'}) ? $request->{'columnName'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  return $self->{impl}->recordFrequency($table, $columnFamily, $columnName, $value);
}

sub fetchRow{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $selector = ($request->{'selector'}) ? $request->{'selector'} : undef;
  return $self->{impl}->fetchRow($table, $selector);
}

sub mutate{
  my ($self, $request) = @_;

  my $mutation = ($request->{'mutation'}) ? $request->{'mutation'} : undef;
  return $self->{impl}->mutate($mutation);
}

sub mutateBatch{
  my ($self, $request) = @_;

  my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
  return $self->{impl}->mutateBatch($mutations);
}

sub createTable{
  my ($self, $request) = @_;

  my $tableDescriptor = ($request->{'tableDescriptor'}) ? $request->{'tableDescriptor'} : undef;
  return $self->{impl}->createTable($tableDescriptor);
}

sub enableTable{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->enableTable($table);
}

sub disableTable{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->disableTable($table);
}

sub removeTable{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $deleteIndexFiles = ($request->{'deleteIndexFiles'}) ? $request->{'deleteIndexFiles'} : undef;
  return $self->{impl}->removeTable($table, $deleteIndexFiles);
}

sub optimize{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $numberOfSegmentsPerShard = ($request->{'numberOfSegmentsPerShard'}) ? $request->{'numberOfSegmentsPerShard'} : undef;
  return $self->{impl}->optimize($table, $numberOfSegmentsPerShard);
}

sub isInSafeMode{
  my ($self, $request) = @_;

  my $cluster = ($request->{'cluster'}) ? $request->{'cluster'} : undef;
  return $self->{impl}->isInSafeMode($cluster);
}

package Blur::BlurClient;


use base qw(Blur::BlurIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub shardClusterList{
  my $self = shift;

    $self->send_shardClusterList();
  return $self->recv_shardClusterList();
}

sub send_shardClusterList{
  my $self = shift;

  $self->{output}->writeMessageBegin('shardClusterList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardClusterList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardClusterList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardClusterList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardClusterList failed: unknown result";
}
sub shardServerList{
  my $self = shift;
  my $cluster = shift;

    $self->send_shardServerList($cluster);
  return $self->recv_shardServerList();
}

sub send_shardServerList{
  my $self = shift;
  my $cluster = shift;

  $self->{output}->writeMessageBegin('shardServerList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardServerList_args();
  $args->{cluster} = $cluster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardServerList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardServerList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardServerList failed: unknown result";
}
sub controllerServerList{
  my $self = shift;

    $self->send_controllerServerList();
  return $self->recv_controllerServerList();
}

sub send_controllerServerList{
  my $self = shift;

  $self->{output}->writeMessageBegin('controllerServerList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_controllerServerList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_controllerServerList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_controllerServerList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "controllerServerList failed: unknown result";
}
sub shardServerLayout{
  my $self = shift;
  my $table = shift;

    $self->send_shardServerLayout($table);
  return $self->recv_shardServerLayout();
}

sub send_shardServerLayout{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('shardServerLayout', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardServerLayout_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardServerLayout{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardServerLayout_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardServerLayout failed: unknown result";
}
sub tableList{
  my $self = shift;

    $self->send_tableList();
  return $self->recv_tableList();
}

sub send_tableList{
  my $self = shift;

  $self->{output}->writeMessageBegin('tableList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_tableList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tableList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_tableList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "tableList failed: unknown result";
}
sub tableListByCluster{
  my $self = shift;
  my $cluster = shift;

    $self->send_tableListByCluster($cluster);
  return $self->recv_tableListByCluster();
}

sub send_tableListByCluster{
  my $self = shift;
  my $cluster = shift;

  $self->{output}->writeMessageBegin('tableListByCluster', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_tableListByCluster_args();
  $args->{cluster} = $cluster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tableListByCluster{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_tableListByCluster_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "tableListByCluster failed: unknown result";
}
sub describe{
  my $self = shift;
  my $table = shift;

    $self->send_describe($table);
  return $self->recv_describe();
}

sub send_describe{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('describe', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_describe_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_describe_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "describe failed: unknown result";
}
sub query{
  my $self = shift;
  my $table = shift;
  my $blurQuery = shift;

    $self->send_query($table, $blurQuery);
  return $self->recv_query();
}

sub send_query{
  my $self = shift;
  my $table = shift;
  my $blurQuery = shift;

  $self->{output}->writeMessageBegin('query', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_query_args();
  $args->{table} = $table;
  $args->{blurQuery} = $blurQuery;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "query failed: unknown result";
}
sub cancelQuery{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

    $self->send_cancelQuery($table, $uuid);
  $self->recv_cancelQuery();
}

sub send_cancelQuery{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  $self->{output}->writeMessageBegin('cancelQuery', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_cancelQuery_args();
  $args->{table} = $table;
  $args->{uuid} = $uuid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancelQuery{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_cancelQuery_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub currentQueries{
  my $self = shift;
  my $table = shift;

    $self->send_currentQueries($table);
  return $self->recv_currentQueries();
}

sub send_currentQueries{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('currentQueries', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_currentQueries_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_currentQueries{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_currentQueries_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "currentQueries failed: unknown result";
}
sub queryStatusIdList{
  my $self = shift;
  my $table = shift;

    $self->send_queryStatusIdList($table);
  return $self->recv_queryStatusIdList();
}

sub send_queryStatusIdList{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('queryStatusIdList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_queryStatusIdList_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_queryStatusIdList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_queryStatusIdList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "queryStatusIdList failed: unknown result";
}
sub queryStatusById{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

    $self->send_queryStatusById($table, $uuid);
  return $self->recv_queryStatusById();
}

sub send_queryStatusById{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  $self->{output}->writeMessageBegin('queryStatusById', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_queryStatusById_args();
  $args->{table} = $table;
  $args->{uuid} = $uuid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_queryStatusById{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_queryStatusById_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "queryStatusById failed: unknown result";
}
sub schema{
  my $self = shift;
  my $table = shift;

    $self->send_schema($table);
  return $self->recv_schema();
}

sub send_schema{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('schema', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_schema_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_schema_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "schema failed: unknown result";
}
sub getTableStats{
  my $self = shift;
  my $table = shift;

    $self->send_getTableStats($table);
  return $self->recv_getTableStats();
}

sub send_getTableStats{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('getTableStats', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_getTableStats_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getTableStats{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_getTableStats_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "getTableStats failed: unknown result";
}
sub terms{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $startWith = shift;
  my $size = shift;

    $self->send_terms($table, $columnFamily, $columnName, $startWith, $size);
  return $self->recv_terms();
}

sub send_terms{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $startWith = shift;
  my $size = shift;

  $self->{output}->writeMessageBegin('terms', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_terms_args();
  $args->{table} = $table;
  $args->{columnFamily} = $columnFamily;
  $args->{columnName} = $columnName;
  $args->{startWith} = $startWith;
  $args->{size} = $size;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_terms{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_terms_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "terms failed: unknown result";
}
sub recordFrequency{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $value = shift;

    $self->send_recordFrequency($table, $columnFamily, $columnName, $value);
  return $self->recv_recordFrequency();
}

sub send_recordFrequency{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $value = shift;

  $self->{output}->writeMessageBegin('recordFrequency', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_recordFrequency_args();
  $args->{table} = $table;
  $args->{columnFamily} = $columnFamily;
  $args->{columnName} = $columnName;
  $args->{value} = $value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_recordFrequency{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_recordFrequency_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "recordFrequency failed: unknown result";
}
sub fetchRow{
  my $self = shift;
  my $table = shift;
  my $selector = shift;

    $self->send_fetchRow($table, $selector);
  return $self->recv_fetchRow();
}

sub send_fetchRow{
  my $self = shift;
  my $table = shift;
  my $selector = shift;

  $self->{output}->writeMessageBegin('fetchRow', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_fetchRow_args();
  $args->{table} = $table;
  $args->{selector} = $selector;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_fetchRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_fetchRow_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "fetchRow failed: unknown result";
}
sub mutate{
  my $self = shift;
  my $mutation = shift;

    $self->send_mutate($mutation);
  $self->recv_mutate();
}

sub send_mutate{
  my $self = shift;
  my $mutation = shift;

  $self->{output}->writeMessageBegin('mutate', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_mutate_args();
  $args->{mutation} = $mutation;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_mutate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub mutateBatch{
  my $self = shift;
  my $mutations = shift;

    $self->send_mutateBatch($mutations);
  $self->recv_mutateBatch();
}

sub send_mutateBatch{
  my $self = shift;
  my $mutations = shift;

  $self->{output}->writeMessageBegin('mutateBatch', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_mutateBatch_args();
  $args->{mutations} = $mutations;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateBatch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_mutateBatch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub createTable{
  my $self = shift;
  my $tableDescriptor = shift;

    $self->send_createTable($tableDescriptor);
  $self->recv_createTable();
}

sub send_createTable{
  my $self = shift;
  my $tableDescriptor = shift;

  $self->{output}->writeMessageBegin('createTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_createTable_args();
  $args->{tableDescriptor} = $tableDescriptor;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_createTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub enableTable{
  my $self = shift;
  my $table = shift;

    $self->send_enableTable($table);
  $self->recv_enableTable();
}

sub send_enableTable{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('enableTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_enableTable_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_enableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_enableTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub disableTable{
  my $self = shift;
  my $table = shift;

    $self->send_disableTable($table);
  $self->recv_disableTable();
}

sub send_disableTable{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('disableTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_disableTable_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_disableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_disableTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub removeTable{
  my $self = shift;
  my $table = shift;
  my $deleteIndexFiles = shift;

    $self->send_removeTable($table, $deleteIndexFiles);
  $self->recv_removeTable();
}

sub send_removeTable{
  my $self = shift;
  my $table = shift;
  my $deleteIndexFiles = shift;

  $self->{output}->writeMessageBegin('removeTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_removeTable_args();
  $args->{table} = $table;
  $args->{deleteIndexFiles} = $deleteIndexFiles;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_removeTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_removeTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub optimize{
  my $self = shift;
  my $table = shift;
  my $numberOfSegmentsPerShard = shift;

    $self->send_optimize($table, $numberOfSegmentsPerShard);
  $self->recv_optimize();
}

sub send_optimize{
  my $self = shift;
  my $table = shift;
  my $numberOfSegmentsPerShard = shift;

  $self->{output}->writeMessageBegin('optimize', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_optimize_args();
  $args->{table} = $table;
  $args->{numberOfSegmentsPerShard} = $numberOfSegmentsPerShard;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_optimize{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_optimize_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub isInSafeMode{
  my $self = shift;
  my $cluster = shift;

    $self->send_isInSafeMode($cluster);
  return $self->recv_isInSafeMode();
}

sub send_isInSafeMode{
  my $self = shift;
  my $cluster = shift;

  $self->{output}->writeMessageBegin('isInSafeMode', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_isInSafeMode_args();
  $args->{cluster} = $cluster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_isInSafeMode{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_isInSafeMode_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "isInSafeMode failed: unknown result";
}
package Blur::BlurProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_shardClusterList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardClusterList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardClusterList_result();
    eval {
      $result->{success} = $self->{handler}->shardClusterList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardClusterList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardServerList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardServerList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardServerList_result();
    eval {
      $result->{success} = $self->{handler}->shardServerList($args->cluster);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardServerList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_controllerServerList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_controllerServerList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_controllerServerList_result();
    eval {
      $result->{success} = $self->{handler}->controllerServerList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('controllerServerList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardServerLayout {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardServerLayout_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardServerLayout_result();
    eval {
      $result->{success} = $self->{handler}->shardServerLayout($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardServerLayout', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tableList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_tableList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_tableList_result();
    eval {
      $result->{success} = $self->{handler}->tableList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('tableList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tableListByCluster {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_tableListByCluster_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_tableListByCluster_result();
    eval {
      $result->{success} = $self->{handler}->tableListByCluster($args->cluster);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('tableListByCluster', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_describe_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_describe_result();
    eval {
      $result->{success} = $self->{handler}->describe($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('describe', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_query_result();
    eval {
      $result->{success} = $self->{handler}->query($args->table, $args->blurQuery);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancelQuery {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_cancelQuery_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_cancelQuery_result();
    eval {
      $self->{handler}->cancelQuery($args->table, $args->uuid);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('cancelQuery', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_currentQueries {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_currentQueries_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_currentQueries_result();
    eval {
      $result->{success} = $self->{handler}->currentQueries($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('currentQueries', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_queryStatusIdList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_queryStatusIdList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_queryStatusIdList_result();
    eval {
      $result->{success} = $self->{handler}->queryStatusIdList($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('queryStatusIdList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_queryStatusById {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_queryStatusById_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_queryStatusById_result();
    eval {
      $result->{success} = $self->{handler}->queryStatusById($args->table, $args->uuid);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('queryStatusById', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_schema_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_schema_result();
    eval {
      $result->{success} = $self->{handler}->schema($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('schema', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getTableStats {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_getTableStats_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_getTableStats_result();
    eval {
      $result->{success} = $self->{handler}->getTableStats($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('getTableStats', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_terms {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_terms_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_terms_result();
    eval {
      $result->{success} = $self->{handler}->terms($args->table, $args->columnFamily, $args->columnName, $args->startWith, $args->size);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('terms', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_recordFrequency {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_recordFrequency_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_recordFrequency_result();
    eval {
      $result->{success} = $self->{handler}->recordFrequency($args->table, $args->columnFamily, $args->columnName, $args->value);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('recordFrequency', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_fetchRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_fetchRow_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_fetchRow_result();
    eval {
      $result->{success} = $self->{handler}->fetchRow($args->table, $args->selector);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('fetchRow', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_mutate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_mutate_result();
    eval {
      $self->{handler}->mutate($args->mutation);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('mutate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateBatch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_mutateBatch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_mutateBatch_result();
    eval {
      $self->{handler}->mutateBatch($args->mutations);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('mutateBatch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_createTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_createTable_result();
    eval {
      $self->{handler}->createTable($args->tableDescriptor);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('createTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_enableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_enableTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_enableTable_result();
    eval {
      $self->{handler}->enableTable($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('enableTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_disableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_disableTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_disableTable_result();
    eval {
      $self->{handler}->disableTable($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('disableTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_removeTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_removeTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_removeTable_result();
    eval {
      $self->{handler}->removeTable($args->table, $args->deleteIndexFiles);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('removeTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_optimize {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_optimize_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_optimize_result();
    eval {
      $self->{handler}->optimize($args->table, $args->numberOfSegmentsPerShard);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('optimize', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_isInSafeMode {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_isInSafeMode_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_isInSafeMode_result();
    eval {
      $result->{success} = $self->{handler}->isInSafeMode($args->cluster);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('isInSafeMode', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
