#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require 'blur_types'

module Blur
  module Blur
    class Client
      include ::Thrift::Client

      def listInstalledCommands()
        send_listInstalledCommands()
        return recv_listInstalledCommands()
      end

      def send_listInstalledCommands()
        send_message('listInstalledCommands', ListInstalledCommands_args)
      end

      def recv_listInstalledCommands()
        result = receive_message(ListInstalledCommands_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'listInstalledCommands failed: unknown result')
      end

      def execute(commandName, arguments)
        send_execute(commandName, arguments)
        return recv_execute()
      end

      def send_execute(commandName, arguments)
        send_message('execute', Execute_args, :commandName => commandName, :arguments => arguments)
      end

      def recv_execute()
        result = receive_message(Execute_result)
        return result.success unless result.success.nil?
        raise result.bex unless result.bex.nil?
        raise result.tex unless result.tex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'execute failed: unknown result')
      end

      def reconnect(instanceExecutionId)
        send_reconnect(instanceExecutionId)
        return recv_reconnect()
      end

      def send_reconnect(instanceExecutionId)
        send_message('reconnect', Reconnect_args, :instanceExecutionId => instanceExecutionId)
      end

      def recv_reconnect()
        result = receive_message(Reconnect_result)
        return result.success unless result.success.nil?
        raise result.bex unless result.bex.nil?
        raise result.tex unless result.tex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'reconnect failed: unknown result')
      end

      def commandStatusList(startingAt, fetch, state)
        send_commandStatusList(startingAt, fetch, state)
        return recv_commandStatusList()
      end

      def send_commandStatusList(startingAt, fetch, state)
        send_message('commandStatusList', CommandStatusList_args, :startingAt => startingAt, :fetch => fetch, :state => state)
      end

      def recv_commandStatusList()
        result = receive_message(CommandStatusList_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'commandStatusList failed: unknown result')
      end

      def commandStatus(commandExecutionId)
        send_commandStatus(commandExecutionId)
        return recv_commandStatus()
      end

      def send_commandStatus(commandExecutionId)
        send_message('commandStatus', CommandStatus_args, :commandExecutionId => commandExecutionId)
      end

      def recv_commandStatus()
        result = receive_message(CommandStatus_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'commandStatus failed: unknown result')
      end

      def commandCancel(commandExecutionId)
        send_commandCancel(commandExecutionId)
        recv_commandCancel()
      end

      def send_commandCancel(commandExecutionId)
        send_message('commandCancel', CommandCancel_args, :commandExecutionId => commandExecutionId)
      end

      def recv_commandCancel()
        result = receive_message(CommandCancel_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def refresh()
        send_refresh()
      end

      def send_refresh()
        send_message('refresh', Refresh_args)
      end
      def executeCommand(commandRequest)
        send_executeCommand(commandRequest)
      end

      def send_executeCommand(commandRequest)
        send_message('executeCommand', ExecuteCommand_args, :commandRequest => commandRequest)
      end
      def createTable(tableDescriptor)
        send_createTable(tableDescriptor)
        recv_createTable()
      end

      def send_createTable(tableDescriptor)
        send_message('createTable', CreateTable_args, :tableDescriptor => tableDescriptor)
      end

      def recv_createTable()
        result = receive_message(CreateTable_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def enableTable(table)
        send_enableTable(table)
        recv_enableTable()
      end

      def send_enableTable(table)
        send_message('enableTable', EnableTable_args, :table => table)
      end

      def recv_enableTable()
        result = receive_message(EnableTable_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def disableTable(table)
        send_disableTable(table)
        recv_disableTable()
      end

      def send_disableTable(table)
        send_message('disableTable', DisableTable_args, :table => table)
      end

      def recv_disableTable()
        result = receive_message(DisableTable_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def removeTable(table, deleteIndexFiles)
        send_removeTable(table, deleteIndexFiles)
        recv_removeTable()
      end

      def send_removeTable(table, deleteIndexFiles)
        send_message('removeTable', RemoveTable_args, :table => table, :deleteIndexFiles => deleteIndexFiles)
      end

      def recv_removeTable()
        result = receive_message(RemoveTable_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def addColumnDefinition(table, columnDefinition)
        send_addColumnDefinition(table, columnDefinition)
        return recv_addColumnDefinition()
      end

      def send_addColumnDefinition(table, columnDefinition)
        send_message('addColumnDefinition', AddColumnDefinition_args, :table => table, :columnDefinition => columnDefinition)
      end

      def recv_addColumnDefinition()
        result = receive_message(AddColumnDefinition_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'addColumnDefinition failed: unknown result')
      end

      def tableList()
        send_tableList()
        return recv_tableList()
      end

      def send_tableList()
        send_message('tableList', TableList_args)
      end

      def recv_tableList()
        result = receive_message(TableList_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'tableList failed: unknown result')
      end

      def tableListByCluster(cluster)
        send_tableListByCluster(cluster)
        return recv_tableListByCluster()
      end

      def send_tableListByCluster(cluster)
        send_message('tableListByCluster', TableListByCluster_args, :cluster => cluster)
      end

      def recv_tableListByCluster()
        result = receive_message(TableListByCluster_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'tableListByCluster failed: unknown result')
      end

      def describe(table)
        send_describe(table)
        return recv_describe()
      end

      def send_describe(table)
        send_message('describe', Describe_args, :table => table)
      end

      def recv_describe()
        result = receive_message(Describe_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'describe failed: unknown result')
      end

      def schema(table)
        send_schema(table)
        return recv_schema()
      end

      def send_schema(table)
        send_message('schema', Schema_args, :table => table)
      end

      def recv_schema()
        result = receive_message(Schema_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'schema failed: unknown result')
      end

      def parseQuery(table, query)
        send_parseQuery(table, query)
        return recv_parseQuery()
      end

      def send_parseQuery(table, query)
        send_message('parseQuery', ParseQuery_args, :table => table, :query => query)
      end

      def recv_parseQuery()
        result = receive_message(ParseQuery_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'parseQuery failed: unknown result')
      end

      def tableStats(table)
        send_tableStats(table)
        return recv_tableStats()
      end

      def send_tableStats(table)
        send_message('tableStats', TableStats_args, :table => table)
      end

      def recv_tableStats()
        result = receive_message(TableStats_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'tableStats failed: unknown result')
      end

      def optimize(table, numberOfSegmentsPerShard)
        send_optimize(table, numberOfSegmentsPerShard)
        recv_optimize()
      end

      def send_optimize(table, numberOfSegmentsPerShard)
        send_message('optimize', Optimize_args, :table => table, :numberOfSegmentsPerShard => numberOfSegmentsPerShard)
      end

      def recv_optimize()
        result = receive_message(Optimize_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def createSnapshot(table, name)
        send_createSnapshot(table, name)
        recv_createSnapshot()
      end

      def send_createSnapshot(table, name)
        send_message('createSnapshot', CreateSnapshot_args, :table => table, :name => name)
      end

      def recv_createSnapshot()
        result = receive_message(CreateSnapshot_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def removeSnapshot(table, name)
        send_removeSnapshot(table, name)
        recv_removeSnapshot()
      end

      def send_removeSnapshot(table, name)
        send_message('removeSnapshot', RemoveSnapshot_args, :table => table, :name => name)
      end

      def recv_removeSnapshot()
        result = receive_message(RemoveSnapshot_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def listSnapshots(table)
        send_listSnapshots(table)
        return recv_listSnapshots()
      end

      def send_listSnapshots(table)
        send_message('listSnapshots', ListSnapshots_args, :table => table)
      end

      def recv_listSnapshots()
        result = receive_message(ListSnapshots_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'listSnapshots failed: unknown result')
      end

      def setUser(user)
        send_setUser(user)
      end

      def send_setUser(user)
        send_message('setUser', SetUser_args, :user => user)
      end
      def query(table, blurQuery)
        send_query(table, blurQuery)
        return recv_query()
      end

      def send_query(table, blurQuery)
        send_message('query', Query_args, :table => table, :blurQuery => blurQuery)
      end

      def recv_query()
        result = receive_message(Query_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'query failed: unknown result')
      end

      def fetchRow(table, selector)
        send_fetchRow(table, selector)
        return recv_fetchRow()
      end

      def send_fetchRow(table, selector)
        send_message('fetchRow', FetchRow_args, :table => table, :selector => selector)
      end

      def recv_fetchRow()
        result = receive_message(FetchRow_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'fetchRow failed: unknown result')
      end

      def fetchRowBatch(table, selectors)
        send_fetchRowBatch(table, selectors)
        return recv_fetchRowBatch()
      end

      def send_fetchRowBatch(table, selectors)
        send_message('fetchRowBatch', FetchRowBatch_args, :table => table, :selectors => selectors)
      end

      def recv_fetchRowBatch()
        result = receive_message(FetchRowBatch_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'fetchRowBatch failed: unknown result')
      end

      def loadData(table, location)
        send_loadData(table, location)
        recv_loadData()
      end

      def send_loadData(table, location)
        send_message('loadData', LoadData_args, :table => table, :location => location)
      end

      def recv_loadData()
        result = receive_message(LoadData_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def validateIndex(table, externalIndexPaths)
        send_validateIndex(table, externalIndexPaths)
        recv_validateIndex()
      end

      def send_validateIndex(table, externalIndexPaths)
        send_message('validateIndex', ValidateIndex_args, :table => table, :externalIndexPaths => externalIndexPaths)
      end

      def recv_validateIndex()
        result = receive_message(ValidateIndex_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def loadIndex(table, externalIndexPaths)
        send_loadIndex(table, externalIndexPaths)
        recv_loadIndex()
      end

      def send_loadIndex(table, externalIndexPaths)
        send_message('loadIndex', LoadIndex_args, :table => table, :externalIndexPaths => externalIndexPaths)
      end

      def recv_loadIndex()
        result = receive_message(LoadIndex_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def mutate(mutation)
        send_mutate(mutation)
        recv_mutate()
      end

      def send_mutate(mutation)
        send_message('mutate', Mutate_args, :mutation => mutation)
      end

      def recv_mutate()
        result = receive_message(Mutate_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def enqueueMutate(mutation)
        send_enqueueMutate(mutation)
        recv_enqueueMutate()
      end

      def send_enqueueMutate(mutation)
        send_message('enqueueMutate', EnqueueMutate_args, :mutation => mutation)
      end

      def recv_enqueueMutate()
        result = receive_message(EnqueueMutate_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def mutateBatch(mutations)
        send_mutateBatch(mutations)
        recv_mutateBatch()
      end

      def send_mutateBatch(mutations)
        send_message('mutateBatch', MutateBatch_args, :mutations => mutations)
      end

      def recv_mutateBatch()
        result = receive_message(MutateBatch_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def enqueueMutateBatch(mutations)
        send_enqueueMutateBatch(mutations)
        recv_enqueueMutateBatch()
      end

      def send_enqueueMutateBatch(mutations)
        send_message('enqueueMutateBatch', EnqueueMutateBatch_args, :mutations => mutations)
      end

      def recv_enqueueMutateBatch()
        result = receive_message(EnqueueMutateBatch_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def bulkMutateStart(bulkId)
        send_bulkMutateStart(bulkId)
        recv_bulkMutateStart()
      end

      def send_bulkMutateStart(bulkId)
        send_message('bulkMutateStart', BulkMutateStart_args, :bulkId => bulkId)
      end

      def recv_bulkMutateStart()
        result = receive_message(BulkMutateStart_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def bulkMutateAdd(bulkId, rowMutation)
        send_bulkMutateAdd(bulkId, rowMutation)
        recv_bulkMutateAdd()
      end

      def send_bulkMutateAdd(bulkId, rowMutation)
        send_message('bulkMutateAdd', BulkMutateAdd_args, :bulkId => bulkId, :rowMutation => rowMutation)
      end

      def recv_bulkMutateAdd()
        result = receive_message(BulkMutateAdd_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def bulkMutateAddMultiple(bulkId, rowMutations)
        send_bulkMutateAddMultiple(bulkId, rowMutations)
        recv_bulkMutateAddMultiple()
      end

      def send_bulkMutateAddMultiple(bulkId, rowMutations)
        send_message('bulkMutateAddMultiple', BulkMutateAddMultiple_args, :bulkId => bulkId, :rowMutations => rowMutations)
      end

      def recv_bulkMutateAddMultiple()
        result = receive_message(BulkMutateAddMultiple_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def bulkMutateFinish(bulkId, apply, blockUntilComplete)
        send_bulkMutateFinish(bulkId, apply, blockUntilComplete)
        recv_bulkMutateFinish()
      end

      def send_bulkMutateFinish(bulkId, apply, blockUntilComplete)
        send_message('bulkMutateFinish', BulkMutateFinish_args, :bulkId => bulkId, :apply => apply, :blockUntilComplete => blockUntilComplete)
      end

      def recv_bulkMutateFinish()
        result = receive_message(BulkMutateFinish_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def cancelQuery(table, uuid)
        send_cancelQuery(table, uuid)
        recv_cancelQuery()
      end

      def send_cancelQuery(table, uuid)
        send_message('cancelQuery', CancelQuery_args, :table => table, :uuid => uuid)
      end

      def recv_cancelQuery()
        result = receive_message(CancelQuery_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def queryStatusIdList(table)
        send_queryStatusIdList(table)
        return recv_queryStatusIdList()
      end

      def send_queryStatusIdList(table)
        send_message('queryStatusIdList', QueryStatusIdList_args, :table => table)
      end

      def recv_queryStatusIdList()
        result = receive_message(QueryStatusIdList_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'queryStatusIdList failed: unknown result')
      end

      def queryStatusById(table, uuid)
        send_queryStatusById(table, uuid)
        return recv_queryStatusById()
      end

      def send_queryStatusById(table, uuid)
        send_message('queryStatusById', QueryStatusById_args, :table => table, :uuid => uuid)
      end

      def recv_queryStatusById()
        result = receive_message(QueryStatusById_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'queryStatusById failed: unknown result')
      end

      def terms(table, columnFamily, columnName, startWith, size)
        send_terms(table, columnFamily, columnName, startWith, size)
        return recv_terms()
      end

      def send_terms(table, columnFamily, columnName, startWith, size)
        send_message('terms', Terms_args, :table => table, :columnFamily => columnFamily, :columnName => columnName, :startWith => startWith, :size => size)
      end

      def recv_terms()
        result = receive_message(Terms_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'terms failed: unknown result')
      end

      def recordFrequency(table, columnFamily, columnName, value)
        send_recordFrequency(table, columnFamily, columnName, value)
        return recv_recordFrequency()
      end

      def send_recordFrequency(table, columnFamily, columnName, value)
        send_message('recordFrequency', RecordFrequency_args, :table => table, :columnFamily => columnFamily, :columnName => columnName, :value => value)
      end

      def recv_recordFrequency()
        result = receive_message(RecordFrequency_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'recordFrequency failed: unknown result')
      end

      def shardClusterList()
        send_shardClusterList()
        return recv_shardClusterList()
      end

      def send_shardClusterList()
        send_message('shardClusterList', ShardClusterList_args)
      end

      def recv_shardClusterList()
        result = receive_message(ShardClusterList_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'shardClusterList failed: unknown result')
      end

      def shardServerList(cluster)
        send_shardServerList(cluster)
        return recv_shardServerList()
      end

      def send_shardServerList(cluster)
        send_message('shardServerList', ShardServerList_args, :cluster => cluster)
      end

      def recv_shardServerList()
        result = receive_message(ShardServerList_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'shardServerList failed: unknown result')
      end

      def controllerServerList()
        send_controllerServerList()
        return recv_controllerServerList()
      end

      def send_controllerServerList()
        send_message('controllerServerList', ControllerServerList_args)
      end

      def recv_controllerServerList()
        result = receive_message(ControllerServerList_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'controllerServerList failed: unknown result')
      end

      def shardServerLayout(table)
        send_shardServerLayout(table)
        return recv_shardServerLayout()
      end

      def send_shardServerLayout(table)
        send_message('shardServerLayout', ShardServerLayout_args, :table => table)
      end

      def recv_shardServerLayout()
        result = receive_message(ShardServerLayout_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'shardServerLayout failed: unknown result')
      end

      def shardServerLayoutState(table)
        send_shardServerLayoutState(table)
        return recv_shardServerLayoutState()
      end

      def send_shardServerLayoutState(table)
        send_message('shardServerLayoutState', ShardServerLayoutState_args, :table => table)
      end

      def recv_shardServerLayoutState()
        result = receive_message(ShardServerLayoutState_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'shardServerLayoutState failed: unknown result')
      end

      def isInSafeMode(cluster)
        send_isInSafeMode(cluster)
        return recv_isInSafeMode()
      end

      def send_isInSafeMode(cluster)
        send_message('isInSafeMode', IsInSafeMode_args, :cluster => cluster)
      end

      def recv_isInSafeMode()
        result = receive_message(IsInSafeMode_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'isInSafeMode failed: unknown result')
      end

      def configuration()
        send_configuration()
        return recv_configuration()
      end

      def send_configuration()
        send_message('configuration', Configuration_args)
      end

      def recv_configuration()
        result = receive_message(Configuration_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'configuration failed: unknown result')
      end

      def configurationPerServer(thriftServerPlusPort, configName)
        send_configurationPerServer(thriftServerPlusPort, configName)
        return recv_configurationPerServer()
      end

      def send_configurationPerServer(thriftServerPlusPort, configName)
        send_message('configurationPerServer', ConfigurationPerServer_args, :thriftServerPlusPort => thriftServerPlusPort, :configName => configName)
      end

      def recv_configurationPerServer()
        result = receive_message(ConfigurationPerServer_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'configurationPerServer failed: unknown result')
      end

      def metrics(metrics)
        send_metrics(metrics)
        return recv_metrics()
      end

      def send_metrics(metrics)
        send_message('metrics', Metrics_args, :metrics => metrics)
      end

      def recv_metrics()
        result = receive_message(Metrics_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'metrics failed: unknown result')
      end

      def startTrace(traceId, requestId)
        send_startTrace(traceId, requestId)
      end

      def send_startTrace(traceId, requestId)
        send_message('startTrace', StartTrace_args, :traceId => traceId, :requestId => requestId)
      end
      def traceList()
        send_traceList()
        return recv_traceList()
      end

      def send_traceList()
        send_message('traceList', TraceList_args)
      end

      def recv_traceList()
        result = receive_message(TraceList_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'traceList failed: unknown result')
      end

      def traceRequestList(traceId)
        send_traceRequestList(traceId)
        return recv_traceRequestList()
      end

      def send_traceRequestList(traceId)
        send_message('traceRequestList', TraceRequestList_args, :traceId => traceId)
      end

      def recv_traceRequestList()
        result = receive_message(TraceRequestList_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'traceRequestList failed: unknown result')
      end

      def traceRequestFetch(traceId, requestId)
        send_traceRequestFetch(traceId, requestId)
        return recv_traceRequestFetch()
      end

      def send_traceRequestFetch(traceId, requestId)
        send_message('traceRequestFetch', TraceRequestFetch_args, :traceId => traceId, :requestId => requestId)
      end

      def recv_traceRequestFetch()
        result = receive_message(TraceRequestFetch_result)
        return result.success unless result.success.nil?
        raise result.ex unless result.ex.nil?
        raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'traceRequestFetch failed: unknown result')
      end

      def traceRemove(traceId)
        send_traceRemove(traceId)
        recv_traceRemove()
      end

      def send_traceRemove(traceId)
        send_message('traceRemove', TraceRemove_args, :traceId => traceId)
      end

      def recv_traceRemove()
        result = receive_message(TraceRemove_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def ping()
        send_ping()
        recv_ping()
      end

      def send_ping()
        send_message('ping', Ping_args)
      end

      def recv_ping()
        result = receive_message(Ping_result)
        return
      end

      def logging(classNameOrLoggerName, level)
        send_logging(classNameOrLoggerName, level)
        recv_logging()
      end

      def send_logging(classNameOrLoggerName, level)
        send_message('logging', Logging_args, :classNameOrLoggerName => classNameOrLoggerName, :level => level)
      end

      def recv_logging()
        result = receive_message(Logging_result)
        raise result.ex unless result.ex.nil?
        return
      end

      def resetLogging()
        send_resetLogging()
        recv_resetLogging()
      end

      def send_resetLogging()
        send_message('resetLogging', ResetLogging_args)
      end

      def recv_resetLogging()
        result = receive_message(ResetLogging_result)
        raise result.ex unless result.ex.nil?
        return
      end

    end

    class Processor
      include ::Thrift::Processor

      def process_listInstalledCommands(seqid, iprot, oprot)
        args = read_args(iprot, ListInstalledCommands_args)
        result = ListInstalledCommands_result.new()
        begin
          result.success = @handler.listInstalledCommands()
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'listInstalledCommands', seqid)
      end

      def process_execute(seqid, iprot, oprot)
        args = read_args(iprot, Execute_args)
        result = Execute_result.new()
        begin
          result.success = @handler.execute(args.commandName, args.arguments)
        rescue ::Blur::BlurException => bex
          result.bex = bex
        rescue ::Blur::TimeoutException => tex
          result.tex = tex
        end
        write_result(result, oprot, 'execute', seqid)
      end

      def process_reconnect(seqid, iprot, oprot)
        args = read_args(iprot, Reconnect_args)
        result = Reconnect_result.new()
        begin
          result.success = @handler.reconnect(args.instanceExecutionId)
        rescue ::Blur::BlurException => bex
          result.bex = bex
        rescue ::Blur::TimeoutException => tex
          result.tex = tex
        end
        write_result(result, oprot, 'reconnect', seqid)
      end

      def process_commandStatusList(seqid, iprot, oprot)
        args = read_args(iprot, CommandStatusList_args)
        result = CommandStatusList_result.new()
        begin
          result.success = @handler.commandStatusList(args.startingAt, args.fetch, args.state)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'commandStatusList', seqid)
      end

      def process_commandStatus(seqid, iprot, oprot)
        args = read_args(iprot, CommandStatus_args)
        result = CommandStatus_result.new()
        begin
          result.success = @handler.commandStatus(args.commandExecutionId)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'commandStatus', seqid)
      end

      def process_commandCancel(seqid, iprot, oprot)
        args = read_args(iprot, CommandCancel_args)
        result = CommandCancel_result.new()
        begin
          @handler.commandCancel(args.commandExecutionId)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'commandCancel', seqid)
      end

      def process_refresh(seqid, iprot, oprot)
        args = read_args(iprot, Refresh_args)
        @handler.refresh()
        return
      end

      def process_executeCommand(seqid, iprot, oprot)
        args = read_args(iprot, ExecuteCommand_args)
        @handler.executeCommand(args.commandRequest)
        return
      end

      def process_createTable(seqid, iprot, oprot)
        args = read_args(iprot, CreateTable_args)
        result = CreateTable_result.new()
        begin
          @handler.createTable(args.tableDescriptor)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'createTable', seqid)
      end

      def process_enableTable(seqid, iprot, oprot)
        args = read_args(iprot, EnableTable_args)
        result = EnableTable_result.new()
        begin
          @handler.enableTable(args.table)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'enableTable', seqid)
      end

      def process_disableTable(seqid, iprot, oprot)
        args = read_args(iprot, DisableTable_args)
        result = DisableTable_result.new()
        begin
          @handler.disableTable(args.table)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'disableTable', seqid)
      end

      def process_removeTable(seqid, iprot, oprot)
        args = read_args(iprot, RemoveTable_args)
        result = RemoveTable_result.new()
        begin
          @handler.removeTable(args.table, args.deleteIndexFiles)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'removeTable', seqid)
      end

      def process_addColumnDefinition(seqid, iprot, oprot)
        args = read_args(iprot, AddColumnDefinition_args)
        result = AddColumnDefinition_result.new()
        begin
          result.success = @handler.addColumnDefinition(args.table, args.columnDefinition)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'addColumnDefinition', seqid)
      end

      def process_tableList(seqid, iprot, oprot)
        args = read_args(iprot, TableList_args)
        result = TableList_result.new()
        begin
          result.success = @handler.tableList()
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'tableList', seqid)
      end

      def process_tableListByCluster(seqid, iprot, oprot)
        args = read_args(iprot, TableListByCluster_args)
        result = TableListByCluster_result.new()
        begin
          result.success = @handler.tableListByCluster(args.cluster)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'tableListByCluster', seqid)
      end

      def process_describe(seqid, iprot, oprot)
        args = read_args(iprot, Describe_args)
        result = Describe_result.new()
        begin
          result.success = @handler.describe(args.table)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'describe', seqid)
      end

      def process_schema(seqid, iprot, oprot)
        args = read_args(iprot, Schema_args)
        result = Schema_result.new()
        begin
          result.success = @handler.schema(args.table)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'schema', seqid)
      end

      def process_parseQuery(seqid, iprot, oprot)
        args = read_args(iprot, ParseQuery_args)
        result = ParseQuery_result.new()
        begin
          result.success = @handler.parseQuery(args.table, args.query)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'parseQuery', seqid)
      end

      def process_tableStats(seqid, iprot, oprot)
        args = read_args(iprot, TableStats_args)
        result = TableStats_result.new()
        begin
          result.success = @handler.tableStats(args.table)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'tableStats', seqid)
      end

      def process_optimize(seqid, iprot, oprot)
        args = read_args(iprot, Optimize_args)
        result = Optimize_result.new()
        begin
          @handler.optimize(args.table, args.numberOfSegmentsPerShard)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'optimize', seqid)
      end

      def process_createSnapshot(seqid, iprot, oprot)
        args = read_args(iprot, CreateSnapshot_args)
        result = CreateSnapshot_result.new()
        begin
          @handler.createSnapshot(args.table, args.name)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'createSnapshot', seqid)
      end

      def process_removeSnapshot(seqid, iprot, oprot)
        args = read_args(iprot, RemoveSnapshot_args)
        result = RemoveSnapshot_result.new()
        begin
          @handler.removeSnapshot(args.table, args.name)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'removeSnapshot', seqid)
      end

      def process_listSnapshots(seqid, iprot, oprot)
        args = read_args(iprot, ListSnapshots_args)
        result = ListSnapshots_result.new()
        begin
          result.success = @handler.listSnapshots(args.table)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'listSnapshots', seqid)
      end

      def process_setUser(seqid, iprot, oprot)
        args = read_args(iprot, SetUser_args)
        @handler.setUser(args.user)
        return
      end

      def process_query(seqid, iprot, oprot)
        args = read_args(iprot, Query_args)
        result = Query_result.new()
        begin
          result.success = @handler.query(args.table, args.blurQuery)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'query', seqid)
      end

      def process_fetchRow(seqid, iprot, oprot)
        args = read_args(iprot, FetchRow_args)
        result = FetchRow_result.new()
        begin
          result.success = @handler.fetchRow(args.table, args.selector)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'fetchRow', seqid)
      end

      def process_fetchRowBatch(seqid, iprot, oprot)
        args = read_args(iprot, FetchRowBatch_args)
        result = FetchRowBatch_result.new()
        begin
          result.success = @handler.fetchRowBatch(args.table, args.selectors)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'fetchRowBatch', seqid)
      end

      def process_loadData(seqid, iprot, oprot)
        args = read_args(iprot, LoadData_args)
        result = LoadData_result.new()
        begin
          @handler.loadData(args.table, args.location)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'loadData', seqid)
      end

      def process_validateIndex(seqid, iprot, oprot)
        args = read_args(iprot, ValidateIndex_args)
        result = ValidateIndex_result.new()
        begin
          @handler.validateIndex(args.table, args.externalIndexPaths)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'validateIndex', seqid)
      end

      def process_loadIndex(seqid, iprot, oprot)
        args = read_args(iprot, LoadIndex_args)
        result = LoadIndex_result.new()
        begin
          @handler.loadIndex(args.table, args.externalIndexPaths)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'loadIndex', seqid)
      end

      def process_mutate(seqid, iprot, oprot)
        args = read_args(iprot, Mutate_args)
        result = Mutate_result.new()
        begin
          @handler.mutate(args.mutation)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'mutate', seqid)
      end

      def process_enqueueMutate(seqid, iprot, oprot)
        args = read_args(iprot, EnqueueMutate_args)
        result = EnqueueMutate_result.new()
        begin
          @handler.enqueueMutate(args.mutation)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'enqueueMutate', seqid)
      end

      def process_mutateBatch(seqid, iprot, oprot)
        args = read_args(iprot, MutateBatch_args)
        result = MutateBatch_result.new()
        begin
          @handler.mutateBatch(args.mutations)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'mutateBatch', seqid)
      end

      def process_enqueueMutateBatch(seqid, iprot, oprot)
        args = read_args(iprot, EnqueueMutateBatch_args)
        result = EnqueueMutateBatch_result.new()
        begin
          @handler.enqueueMutateBatch(args.mutations)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'enqueueMutateBatch', seqid)
      end

      def process_bulkMutateStart(seqid, iprot, oprot)
        args = read_args(iprot, BulkMutateStart_args)
        result = BulkMutateStart_result.new()
        begin
          @handler.bulkMutateStart(args.bulkId)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'bulkMutateStart', seqid)
      end

      def process_bulkMutateAdd(seqid, iprot, oprot)
        args = read_args(iprot, BulkMutateAdd_args)
        result = BulkMutateAdd_result.new()
        begin
          @handler.bulkMutateAdd(args.bulkId, args.rowMutation)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'bulkMutateAdd', seqid)
      end

      def process_bulkMutateAddMultiple(seqid, iprot, oprot)
        args = read_args(iprot, BulkMutateAddMultiple_args)
        result = BulkMutateAddMultiple_result.new()
        begin
          @handler.bulkMutateAddMultiple(args.bulkId, args.rowMutations)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'bulkMutateAddMultiple', seqid)
      end

      def process_bulkMutateFinish(seqid, iprot, oprot)
        args = read_args(iprot, BulkMutateFinish_args)
        result = BulkMutateFinish_result.new()
        begin
          @handler.bulkMutateFinish(args.bulkId, args.apply, args.blockUntilComplete)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'bulkMutateFinish', seqid)
      end

      def process_cancelQuery(seqid, iprot, oprot)
        args = read_args(iprot, CancelQuery_args)
        result = CancelQuery_result.new()
        begin
          @handler.cancelQuery(args.table, args.uuid)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'cancelQuery', seqid)
      end

      def process_queryStatusIdList(seqid, iprot, oprot)
        args = read_args(iprot, QueryStatusIdList_args)
        result = QueryStatusIdList_result.new()
        begin
          result.success = @handler.queryStatusIdList(args.table)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'queryStatusIdList', seqid)
      end

      def process_queryStatusById(seqid, iprot, oprot)
        args = read_args(iprot, QueryStatusById_args)
        result = QueryStatusById_result.new()
        begin
          result.success = @handler.queryStatusById(args.table, args.uuid)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'queryStatusById', seqid)
      end

      def process_terms(seqid, iprot, oprot)
        args = read_args(iprot, Terms_args)
        result = Terms_result.new()
        begin
          result.success = @handler.terms(args.table, args.columnFamily, args.columnName, args.startWith, args.size)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'terms', seqid)
      end

      def process_recordFrequency(seqid, iprot, oprot)
        args = read_args(iprot, RecordFrequency_args)
        result = RecordFrequency_result.new()
        begin
          result.success = @handler.recordFrequency(args.table, args.columnFamily, args.columnName, args.value)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'recordFrequency', seqid)
      end

      def process_shardClusterList(seqid, iprot, oprot)
        args = read_args(iprot, ShardClusterList_args)
        result = ShardClusterList_result.new()
        begin
          result.success = @handler.shardClusterList()
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'shardClusterList', seqid)
      end

      def process_shardServerList(seqid, iprot, oprot)
        args = read_args(iprot, ShardServerList_args)
        result = ShardServerList_result.new()
        begin
          result.success = @handler.shardServerList(args.cluster)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'shardServerList', seqid)
      end

      def process_controllerServerList(seqid, iprot, oprot)
        args = read_args(iprot, ControllerServerList_args)
        result = ControllerServerList_result.new()
        begin
          result.success = @handler.controllerServerList()
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'controllerServerList', seqid)
      end

      def process_shardServerLayout(seqid, iprot, oprot)
        args = read_args(iprot, ShardServerLayout_args)
        result = ShardServerLayout_result.new()
        begin
          result.success = @handler.shardServerLayout(args.table)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'shardServerLayout', seqid)
      end

      def process_shardServerLayoutState(seqid, iprot, oprot)
        args = read_args(iprot, ShardServerLayoutState_args)
        result = ShardServerLayoutState_result.new()
        begin
          result.success = @handler.shardServerLayoutState(args.table)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'shardServerLayoutState', seqid)
      end

      def process_isInSafeMode(seqid, iprot, oprot)
        args = read_args(iprot, IsInSafeMode_args)
        result = IsInSafeMode_result.new()
        begin
          result.success = @handler.isInSafeMode(args.cluster)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'isInSafeMode', seqid)
      end

      def process_configuration(seqid, iprot, oprot)
        args = read_args(iprot, Configuration_args)
        result = Configuration_result.new()
        begin
          result.success = @handler.configuration()
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'configuration', seqid)
      end

      def process_configurationPerServer(seqid, iprot, oprot)
        args = read_args(iprot, ConfigurationPerServer_args)
        result = ConfigurationPerServer_result.new()
        begin
          result.success = @handler.configurationPerServer(args.thriftServerPlusPort, args.configName)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'configurationPerServer', seqid)
      end

      def process_metrics(seqid, iprot, oprot)
        args = read_args(iprot, Metrics_args)
        result = Metrics_result.new()
        begin
          result.success = @handler.metrics(args.metrics)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'metrics', seqid)
      end

      def process_startTrace(seqid, iprot, oprot)
        args = read_args(iprot, StartTrace_args)
        @handler.startTrace(args.traceId, args.requestId)
        return
      end

      def process_traceList(seqid, iprot, oprot)
        args = read_args(iprot, TraceList_args)
        result = TraceList_result.new()
        begin
          result.success = @handler.traceList()
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'traceList', seqid)
      end

      def process_traceRequestList(seqid, iprot, oprot)
        args = read_args(iprot, TraceRequestList_args)
        result = TraceRequestList_result.new()
        begin
          result.success = @handler.traceRequestList(args.traceId)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'traceRequestList', seqid)
      end

      def process_traceRequestFetch(seqid, iprot, oprot)
        args = read_args(iprot, TraceRequestFetch_args)
        result = TraceRequestFetch_result.new()
        begin
          result.success = @handler.traceRequestFetch(args.traceId, args.requestId)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'traceRequestFetch', seqid)
      end

      def process_traceRemove(seqid, iprot, oprot)
        args = read_args(iprot, TraceRemove_args)
        result = TraceRemove_result.new()
        begin
          @handler.traceRemove(args.traceId)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'traceRemove', seqid)
      end

      def process_ping(seqid, iprot, oprot)
        args = read_args(iprot, Ping_args)
        result = Ping_result.new()
        @handler.ping()
        write_result(result, oprot, 'ping', seqid)
      end

      def process_logging(seqid, iprot, oprot)
        args = read_args(iprot, Logging_args)
        result = Logging_result.new()
        begin
          @handler.logging(args.classNameOrLoggerName, args.level)
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'logging', seqid)
      end

      def process_resetLogging(seqid, iprot, oprot)
        args = read_args(iprot, ResetLogging_args)
        result = ResetLogging_result.new()
        begin
          @handler.resetLogging()
        rescue ::Blur::BlurException => ex
          result.ex = ex
        end
        write_result(result, oprot, 'resetLogging', seqid)
      end

    end

    # HELPER FUNCTIONS AND STRUCTURES

    class ListInstalledCommands_args
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ListInstalledCommands_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::CommandDescriptor}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Execute_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      COMMANDNAME = 1
      ARGUMENTS = 2

      FIELDS = {
        COMMANDNAME => {:type => ::Thrift::Types::STRING, :name => 'commandName'},
        ARGUMENTS => {:type => ::Thrift::Types::STRUCT, :name => 'arguments', :class => ::Blur::Arguments}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Execute_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      BEX = 1
      TEX = 2

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Blur::Response},
        BEX => {:type => ::Thrift::Types::STRUCT, :name => 'bex', :class => ::Blur::BlurException},
        TEX => {:type => ::Thrift::Types::STRUCT, :name => 'tex', :class => ::Blur::TimeoutException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Reconnect_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      INSTANCEEXECUTIONID = 1

      FIELDS = {
        INSTANCEEXECUTIONID => {:type => ::Thrift::Types::I64, :name => 'instanceExecutionId'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Reconnect_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      BEX = 1
      TEX = 2

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Blur::Response},
        BEX => {:type => ::Thrift::Types::STRUCT, :name => 'bex', :class => ::Blur::BlurException},
        TEX => {:type => ::Thrift::Types::STRUCT, :name => 'tex', :class => ::Blur::TimeoutException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class CommandStatusList_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      STARTINGAT = 1
      FETCH = 2
      STATE = 3

      FIELDS = {
        STARTINGAT => {:type => ::Thrift::Types::I32, :name => 'startingAt'},
        FETCH => {:type => ::Thrift::Types::I16, :name => 'fetch'},
        STATE => {:type => ::Thrift::Types::I32, :name => 'state', :enum_class => ::Blur::CommandStatusState}
      }

      def struct_fields; FIELDS; end

      def validate
        unless @state.nil? || ::Blur::CommandStatusState::VALID_VALUES.include?(@state)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field state!')
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    class CommandStatusList_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class CommandStatus_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      COMMANDEXECUTIONID = 1

      FIELDS = {
        COMMANDEXECUTIONID => {:type => ::Thrift::Types::STRING, :name => 'commandExecutionId'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class CommandStatus_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Blur::CommandStatus},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class CommandCancel_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      COMMANDEXECUTIONID = 1

      FIELDS = {
        COMMANDEXECUTIONID => {:type => ::Thrift::Types::STRING, :name => 'commandExecutionId'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class CommandCancel_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Refresh_args
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Refresh_result
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ExecuteCommand_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      COMMANDREQUEST = 1

      FIELDS = {
        COMMANDREQUEST => {:type => ::Thrift::Types::STRUCT, :name => 'commandRequest', :class => ::Blur::CommandRequest}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ExecuteCommand_result
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class CreateTable_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLEDESCRIPTOR = 1

      FIELDS = {
        # the TableDescriptor.
        TABLEDESCRIPTOR => {:type => ::Thrift::Types::STRUCT, :name => 'tableDescriptor', :class => ::Blur::TableDescriptor}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class CreateTable_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class EnableTable_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class EnableTable_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class DisableTable_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class DisableTable_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class RemoveTable_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      DELETEINDEXFILES = 2

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        # true to remove the index storage and false if to preserve.
        DELETEINDEXFILES => {:type => ::Thrift::Types::BOOL, :name => 'deleteIndexFiles'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class RemoveTable_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class AddColumnDefinition_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      COLUMNDEFINITION = 2

      FIELDS = {
        # the name of the table.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        # the ColumnDefinition.
        COLUMNDEFINITION => {:type => ::Thrift::Types::STRUCT, :name => 'columnDefinition', :class => ::Blur::ColumnDefinition}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class AddColumnDefinition_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::BOOL, :name => 'success'},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TableList_args
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TableList_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TableListByCluster_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      CLUSTER = 1

      FIELDS = {
        # the cluster name.
        CLUSTER => {:type => ::Thrift::Types::STRING, :name => 'cluster'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TableListByCluster_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Describe_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Describe_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Blur::TableDescriptor},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Schema_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Schema_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Blur::Schema},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ParseQuery_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      QUERY = 2

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        # the query to parse.
        QUERY => {:type => ::Thrift::Types::STRUCT, :name => 'query', :class => ::Blur::Query}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ParseQuery_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::STRING, :name => 'success'},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TableStats_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TableStats_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Blur::TableStats},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Optimize_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      NUMBEROFSEGMENTSPERSHARD = 2

      FIELDS = {
        # table the name of the table.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        # the maximum of segments per shard index after the operation is completed.
        NUMBEROFSEGMENTSPERSHARD => {:type => ::Thrift::Types::I32, :name => 'numberOfSegmentsPerShard'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Optimize_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class CreateSnapshot_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      NAME = 2

      FIELDS = {
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        NAME => {:type => ::Thrift::Types::STRING, :name => 'name'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class CreateSnapshot_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class RemoveSnapshot_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      NAME = 2

      FIELDS = {
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        NAME => {:type => ::Thrift::Types::STRING, :name => 'name'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class RemoveSnapshot_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ListSnapshots_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1

      FIELDS = {
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ListSnapshots_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::MAP, :name => 'success', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRING}}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class SetUser_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      USER = 1

      FIELDS = {
        # the User object.
        USER => {:type => ::Thrift::Types::STRUCT, :name => 'user', :class => ::Blur::User}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class SetUser_result
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Query_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      BLURQUERY = 2

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        # the query to execute.
        BLURQUERY => {:type => ::Thrift::Types::STRUCT, :name => 'blurQuery', :class => ::Blur::BlurQuery}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Query_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Blur::BlurResults},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class FetchRow_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      SELECTOR = 2

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        # the Selector to use to fetch the Row or Record.
        SELECTOR => {:type => ::Thrift::Types::STRUCT, :name => 'selector', :class => ::Blur::Selector}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class FetchRow_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Blur::FetchResult},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class FetchRowBatch_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      SELECTORS = 2

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        # the Selector to use to fetch the Row or Record.
        SELECTORS => {:type => ::Thrift::Types::LIST, :name => 'selectors', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::Selector}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class FetchRowBatch_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::FetchResult}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class LoadData_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      LOCATION = 2

      FIELDS = {
        # The table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        # Location of bulk data load.
        LOCATION => {:type => ::Thrift::Types::STRING, :name => 'location'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class LoadData_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ValidateIndex_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      EXTERNALINDEXPATHS = 2

      FIELDS = {
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        EXTERNALINDEXPATHS => {:type => ::Thrift::Types::LIST, :name => 'externalIndexPaths', :element => {:type => ::Thrift::Types::STRING}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ValidateIndex_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class LoadIndex_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      EXTERNALINDEXPATHS = 2

      FIELDS = {
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        EXTERNALINDEXPATHS => {:type => ::Thrift::Types::LIST, :name => 'externalIndexPaths', :element => {:type => ::Thrift::Types::STRING}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class LoadIndex_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Mutate_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      MUTATION = 1

      FIELDS = {
        # the RowMutation.
        MUTATION => {:type => ::Thrift::Types::STRUCT, :name => 'mutation', :class => ::Blur::RowMutation}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Mutate_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class EnqueueMutate_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      MUTATION = 1

      FIELDS = {
        # the RowMutation.
        MUTATION => {:type => ::Thrift::Types::STRUCT, :name => 'mutation', :class => ::Blur::RowMutation}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class EnqueueMutate_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class MutateBatch_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      MUTATIONS = 1

      FIELDS = {
        # the batch of RowMutations.
        MUTATIONS => {:type => ::Thrift::Types::LIST, :name => 'mutations', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::RowMutation}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class MutateBatch_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class EnqueueMutateBatch_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      MUTATIONS = 1

      FIELDS = {
        # the batch of RowMutations.
        MUTATIONS => {:type => ::Thrift::Types::LIST, :name => 'mutations', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::RowMutation}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class EnqueueMutateBatch_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class BulkMutateStart_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      BULKID = 1

      FIELDS = {
        # The bulk id.
        BULKID => {:type => ::Thrift::Types::STRING, :name => 'bulkId'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class BulkMutateStart_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class BulkMutateAdd_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      BULKID = 1
      ROWMUTATION = 2

      FIELDS = {
        # The bulk id.
        BULKID => {:type => ::Thrift::Types::STRING, :name => 'bulkId'},
        # The row mutation.
        ROWMUTATION => {:type => ::Thrift::Types::STRUCT, :name => 'rowMutation', :class => ::Blur::RowMutation}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class BulkMutateAdd_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class BulkMutateAddMultiple_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      BULKID = 1
      ROWMUTATIONS = 2

      FIELDS = {
        # The bulk id.
        BULKID => {:type => ::Thrift::Types::STRING, :name => 'bulkId'},
        # The row mutation.
        ROWMUTATIONS => {:type => ::Thrift::Types::LIST, :name => 'rowMutations', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::RowMutation}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class BulkMutateAddMultiple_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class BulkMutateFinish_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      BULKID = 1
      APPLY = 2
      BLOCKUNTILCOMPLETE = 3

      FIELDS = {
        # The bulk id.
        BULKID => {:type => ::Thrift::Types::STRING, :name => 'bulkId'},
        # Apply the bulk mutate flag.
        APPLY => {:type => ::Thrift::Types::BOOL, :name => 'apply'},
        # If true this call will not block on bulk completion.  This may be required for loader bulk loads.
        BLOCKUNTILCOMPLETE => {:type => ::Thrift::Types::BOOL, :name => 'blockUntilComplete'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class BulkMutateFinish_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class CancelQuery_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      UUID = 2

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        # the uuid of the query.
        UUID => {:type => ::Thrift::Types::STRING, :name => 'uuid'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class CancelQuery_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class QueryStatusIdList_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class QueryStatusIdList_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class QueryStatusById_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      UUID = 2

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        # the uuid of the query.
        UUID => {:type => ::Thrift::Types::STRING, :name => 'uuid'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class QueryStatusById_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Blur::BlurQueryStatus},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Terms_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      COLUMNFAMILY = 2
      COLUMNNAME = 3
      STARTWITH = 4
      SIZE = 5

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        # the column family. If the frequency requested is a system field like "rowid", "recordid", "family", etc then columnFamily can be null.
        COLUMNFAMILY => {:type => ::Thrift::Types::STRING, :name => 'columnFamily'},
        # the column name.
        COLUMNNAME => {:type => ::Thrift::Types::STRING, :name => 'columnName'},
        # the term to start with assuming that you are paging through the term list.
        STARTWITH => {:type => ::Thrift::Types::STRING, :name => 'startWith'},
        # the number to fetch at once.
        SIZE => {:type => ::Thrift::Types::I16, :name => 'size'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Terms_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class RecordFrequency_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1
      COLUMNFAMILY = 2
      COLUMNNAME = 3
      VALUE = 4

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
        # the column family. If the frequency requested is a system field like "rowid", "recordid", "family", etc then columnFamily can be null.
        COLUMNFAMILY => {:type => ::Thrift::Types::STRING, :name => 'columnFamily'},
        # the column name.
        COLUMNNAME => {:type => ::Thrift::Types::STRING, :name => 'columnName'},
        # the value.
        VALUE => {:type => ::Thrift::Types::STRING, :name => 'value'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class RecordFrequency_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::I64, :name => 'success'},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ShardClusterList_args
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ShardClusterList_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ShardServerList_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      CLUSTER = 1

      FIELDS = {
        # the cluster name.
        CLUSTER => {:type => ::Thrift::Types::STRING, :name => 'cluster'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ShardServerList_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ControllerServerList_args
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ControllerServerList_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ShardServerLayout_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ShardServerLayout_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::MAP, :name => 'success', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ShardServerLayoutState_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TABLE = 1

      FIELDS = {
        # the table name.
        TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ShardServerLayoutState_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::MAP, :name => 'success', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I32, :enum_class => ::Blur::ShardState}}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class IsInSafeMode_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      CLUSTER = 1

      FIELDS = {
        # the name of the cluster.
        CLUSTER => {:type => ::Thrift::Types::STRING, :name => 'cluster'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class IsInSafeMode_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::BOOL, :name => 'success'},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Configuration_args
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Configuration_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::MAP, :name => 'success', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ConfigurationPerServer_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      THRIFTSERVERPLUSPORT = 1
      CONFIGNAME = 2

      FIELDS = {
        THRIFTSERVERPLUSPORT => {:type => ::Thrift::Types::STRING, :name => 'thriftServerPlusPort'},
        CONFIGNAME => {:type => ::Thrift::Types::STRING, :name => 'configName'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ConfigurationPerServer_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::STRING, :name => 'success'},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Metrics_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      METRICS = 1

      FIELDS = {
        # the names of the metrics to return.  If null all are returned.
        METRICS => {:type => ::Thrift::Types::SET, :name => 'metrics', :element => {:type => ::Thrift::Types::STRING}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Metrics_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::MAP, :name => 'success', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::Metric}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class StartTrace_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TRACEID = 1
      REQUESTID = 2

      FIELDS = {
        # the trace id.
        TRACEID => {:type => ::Thrift::Types::STRING, :name => 'traceId'},
        # the request id, used to connected remote calls together.  Client can pass null.
        REQUESTID => {:type => ::Thrift::Types::STRING, :name => 'requestId'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class StartTrace_result
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TraceList_args
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TraceList_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TraceRequestList_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TRACEID = 1

      FIELDS = {
        # the trace id.
        TRACEID => {:type => ::Thrift::Types::STRING, :name => 'traceId'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TraceRequestList_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TraceRequestFetch_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TRACEID = 1
      REQUESTID = 2

      FIELDS = {
        # the trace id.
        TRACEID => {:type => ::Thrift::Types::STRING, :name => 'traceId'},
        # the request id.
        REQUESTID => {:type => ::Thrift::Types::STRING, :name => 'requestId'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TraceRequestFetch_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUCCESS = 0
      EX = 1

      FIELDS = {
        SUCCESS => {:type => ::Thrift::Types::STRING, :name => 'success'},
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TraceRemove_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TRACEID = 1

      FIELDS = {
        # the trace id.
        TRACEID => {:type => ::Thrift::Types::STRING, :name => 'traceId'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TraceRemove_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Ping_args
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Ping_result
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Logging_args
      include ::Thrift::Struct, ::Thrift::Struct_Union
      CLASSNAMEORLOGGERNAME = 1
      LEVEL = 2

      FIELDS = {
        # the className or Logger Name of the Logger to be changed.
        CLASSNAMEORLOGGERNAME => {:type => ::Thrift::Types::STRING, :name => 'classNameOrLoggerName'},
        # the logging level.
        LEVEL => {:type => ::Thrift::Types::I32, :name => 'level', :enum_class => ::Blur::Level}
      }

      def struct_fields; FIELDS; end

      def validate
        unless @level.nil? || ::Blur::Level::VALID_VALUES.include?(@level)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field level!')
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Logging_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ResetLogging_args
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ResetLogging_result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EX = 1

      FIELDS = {
        EX => {:type => ::Thrift::Types::STRUCT, :name => 'ex', :class => ::Blur::BlurException}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

  end

end
