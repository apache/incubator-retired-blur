#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module Blur
  module ErrorType
    UNKNOWN = 0
    QUERY_CANCEL = 1
    QUERY_TIMEOUT = 2
    BACK_PRESSURE = 3
    REQUEST_TIMEOUT = 4
    VALUE_MAP = {0 => "UNKNOWN", 1 => "QUERY_CANCEL", 2 => "QUERY_TIMEOUT", 3 => "BACK_PRESSURE", 4 => "REQUEST_TIMEOUT"}
    VALID_VALUES = Set.new([UNKNOWN, QUERY_CANCEL, QUERY_TIMEOUT, BACK_PRESSURE, REQUEST_TIMEOUT]).freeze
  end

  module ScoreType
    SUPER = 0
    AGGREGATE = 1
    BEST = 2
    CONSTANT = 3
    VALUE_MAP = {0 => "SUPER", 1 => "AGGREGATE", 2 => "BEST", 3 => "CONSTANT"}
    VALID_VALUES = Set.new([SUPER, AGGREGATE, BEST, CONSTANT]).freeze
  end

  module QueryState
    RUNNING = 0
    INTERRUPTED = 1
    COMPLETE = 2
    BACK_PRESSURE_INTERRUPTED = 3
    VALUE_MAP = {0 => "RUNNING", 1 => "INTERRUPTED", 2 => "COMPLETE", 3 => "BACK_PRESSURE_INTERRUPTED"}
    VALID_VALUES = Set.new([RUNNING, INTERRUPTED, COMPLETE, BACK_PRESSURE_INTERRUPTED]).freeze
  end

  module Status
    NOT_FOUND = 0
    FOUND = 1
    VALUE_MAP = {0 => "NOT_FOUND", 1 => "FOUND"}
    VALID_VALUES = Set.new([NOT_FOUND, FOUND]).freeze
  end

  module RowMutationType
    DELETE_ROW = 0
    REPLACE_ROW = 1
    UPDATE_ROW = 2
    VALUE_MAP = {0 => "DELETE_ROW", 1 => "REPLACE_ROW", 2 => "UPDATE_ROW"}
    VALID_VALUES = Set.new([DELETE_ROW, REPLACE_ROW, UPDATE_ROW]).freeze
  end

  module RecordMutationType
    DELETE_ENTIRE_RECORD = 0
    REPLACE_ENTIRE_RECORD = 1
    REPLACE_COLUMNS = 2
    APPEND_COLUMN_VALUES = 3
    VALUE_MAP = {0 => "DELETE_ENTIRE_RECORD", 1 => "REPLACE_ENTIRE_RECORD", 2 => "REPLACE_COLUMNS", 3 => "APPEND_COLUMN_VALUES"}
    VALID_VALUES = Set.new([DELETE_ENTIRE_RECORD, REPLACE_ENTIRE_RECORD, REPLACE_COLUMNS, APPEND_COLUMN_VALUES]).freeze
  end

  module ShardState
    OPENING = 0
    OPEN = 1
    OPENING_ERROR = 2
    CLOSING = 3
    CLOSED = 4
    CLOSING_ERROR = 5
    VALUE_MAP = {0 => "OPENING", 1 => "OPEN", 2 => "OPENING_ERROR", 3 => "CLOSING", 4 => "CLOSED", 5 => "CLOSING_ERROR"}
    VALID_VALUES = Set.new([OPENING, OPEN, OPENING_ERROR, CLOSING, CLOSED, CLOSING_ERROR]).freeze
  end

  module Level
    OFF = 0
    FATAL = 1
    ERROR = 2
    WARN = 3
    INFO = 4
    DEBUG = 5
    TRACE = 6
    ALL = 7
    VALUE_MAP = {0 => "OFF", 1 => "FATAL", 2 => "ERROR", 3 => "WARN", 4 => "INFO", 5 => "DEBUG", 6 => "TRACE", 7 => "ALL"}
    VALID_VALUES = Set.new([OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE, ALL]).freeze
  end

  module BlurObjectType
    MAP = 0
    LIST = 1
    NAME = 2
    VALUE = 3
    VALUE_MAP = {0 => "MAP", 1 => "LIST", 2 => "NAME", 3 => "VALUE"}
    VALID_VALUES = Set.new([MAP, LIST, NAME, VALUE]).freeze
  end

  module CommandStatusState
    RUNNING = 0
    INTERRUPTED = 1
    COMPLETE = 2
    BACK_PRESSURE_INTERRUPTED = 3
    VALUE_MAP = {0 => "RUNNING", 1 => "INTERRUPTED", 2 => "COMPLETE", 3 => "BACK_PRESSURE_INTERRUPTED"}
    VALID_VALUES = Set.new([RUNNING, INTERRUPTED, COMPLETE, BACK_PRESSURE_INTERRUPTED]).freeze
  end

  # BlurException that carries a message plus the original stack
# trace (if any).
  class BlurException < ::Thrift::Exception
    include ::Thrift::Struct, ::Thrift::Struct_Union
    MESSAGE = 1
    STACKTRACESTR = 2
    ERRORTYPE = 3

    FIELDS = {
      # The message in the exception.
      MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'},
      # The original stack trace (if any).
      STACKTRACESTR => {:type => ::Thrift::Types::STRING, :name => 'stackTraceStr'},
      ERRORTYPE => {:type => ::Thrift::Types::I32, :name => 'errorType', :enum_class => ::Blur::ErrorType}
    }

    def struct_fields; FIELDS; end

    def validate
      unless @errorType.nil? || ::Blur::ErrorType::VALID_VALUES.include?(@errorType)
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field errorType!')
      end
    end

    ::Thrift::Struct.generate_accessors self
  end

  # TimeoutException occurs before the network connection timeout
# happens so that the client can reconnect.
  class TimeoutException < ::Thrift::Exception
    include ::Thrift::Struct, ::Thrift::Struct_Union
    INSTANCEEXECUTIONID = 1

    FIELDS = {
      INSTANCEEXECUTIONID => {:type => ::Thrift::Types::I64, :name => 'instanceExecutionId'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # The user object is used to pass user context to server
# side session.
  class User
    include ::Thrift::Struct, ::Thrift::Struct_Union
    USERNAME = 1
    ATTRIBUTES = 2

    FIELDS = {
      # username.
      USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username'},
      # map of user attributes.
      ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # Column is the lowest storage element in Blur, it stores a single name and value pair.
  class Column
    include ::Thrift::Struct, ::Thrift::Struct_Union
    NAME = 1
    VALUE = 2

    FIELDS = {
      # The name of the column.
      NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
      # The value to be indexed and stored.
      VALUE => {:type => ::Thrift::Types::STRING, :name => 'value'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # Records contain a list of columns, multiple columns with the same name are allowed.
  class Record
    include ::Thrift::Struct, ::Thrift::Struct_Union
    RECORDID = 1
    FAMILY = 2
    COLUMNS = 3

    FIELDS = {
      # Record id uniquely identifies a record within a single row.
      RECORDID => {:type => ::Thrift::Types::STRING, :name => 'recordId'},
      # The family in which this record resides.
      FAMILY => {:type => ::Thrift::Types::STRING, :name => 'family'},
      # A list of columns, multiple columns with the same name are allowed.
      COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::Column}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # Rows contain a list of records.
  class Row
    include ::Thrift::Struct, ::Thrift::Struct_Union
    ID = 1
    RECORDS = 2

    FIELDS = {
      # The row id.
      ID => {:type => ::Thrift::Types::STRING, :name => 'id'},
      # The list records within the row.  If paging is used this list will only
# reflect the paged records from the selector.
      RECORDS => {:type => ::Thrift::Types::LIST, :name => 'records', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::Record}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # The Query object holds the query string (normal Lucene syntax),
# filters and type of scoring (used when super query is on).
  class Query
    include ::Thrift::Struct, ::Thrift::Struct_Union
    QUERY = 1
    ROWQUERY = 2
    SCORETYPE = 3
    ROWFILTER = 4
    RECORDFILTER = 5

    FIELDS = {
      # A Lucene syntax based query.
      QUERY => {:type => ::Thrift::Types::STRING, :name => 'query'},
      # If the Row query is on, meaning the query will be perform against all the
# Records (joining records in some cases) and the result will be Rows (groupings of Record).
      ROWQUERY => {:type => ::Thrift::Types::BOOL, :name => 'rowQuery', :default => true},
      # The scoring type, see the document on ScoreType for explanation of each score type.
      SCORETYPE => {:type => ::Thrift::Types::I32, :name => 'scoreType', :default =>       0, :enum_class => ::Blur::ScoreType},
      # The Row filter (normal Lucene syntax), is a filter performed
# after the join to filter out entire Rows from the results.  This
# field is ignored when rowQuery is false.
      ROWFILTER => {:type => ::Thrift::Types::STRING, :name => 'rowFilter'},
      # The Record filter (normal Lucene syntax), is a filter performed
# before the join to filter out Records from the results.
      RECORDFILTER => {:type => ::Thrift::Types::STRING, :name => 'recordFilter'}
    }

    def struct_fields; FIELDS; end

    def validate
      unless @scoreType.nil? || ::Blur::ScoreType::VALID_VALUES.include?(@scoreType)
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field scoreType!')
      end
    end

    ::Thrift::Struct.generate_accessors self
  end

  # The HighlightOptions controls how the data is fetched and returned.
  class HighlightOptions
    include ::Thrift::Struct, ::Thrift::Struct_Union
    QUERY = 1
    PRETAG = 2
    POSTTAG = 3

    FIELDS = {
      # The original query is required if used in the Blur.fetchRow call.  If
# the highlightOptions is used in a call to Blur.query then the Query
# passed into the call via the BlurQuery will be used if this query is
# null.  So that means if you use highlighting from the query call you can
# leave this attribute null and it will default to the normal behavior.
      QUERY => {:type => ::Thrift::Types::STRUCT, :name => 'query', :class => ::Blur::Query},
      # The pre tag is the tag that marks the beginning of the highlighting.
      PRETAG => {:type => ::Thrift::Types::STRING, :name => 'preTag', :default => %q"<<<"},
      # The post tag is the tag that marks the end of the highlighting.
      POSTTAG => {:type => ::Thrift::Types::STRING, :name => 'postTag', :default => %q">>>"}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # Select carries the request for information to be retrieved from the stored columns.
  class Selector
    include ::Thrift::Struct, ::Thrift::Struct_Union
    RECORDONLY = 1
    LOCATIONID = 2
    ROWID = 3
    RECORDID = 4
    COLUMNFAMILIESTOFETCH = 5
    COLUMNSTOFETCH = 6
    STARTRECORD = 8
    MAXRECORDSTOFETCH = 9
    HIGHLIGHTOPTIONS = 10
    ORDEROFFAMILIESTOFETCH = 11

    FIELDS = {
      # Fetch the Record only, not the entire Row.
      RECORDONLY => {:type => ::Thrift::Types::BOOL, :name => 'recordOnly'},
      # WARNING: This is an internal only attribute and is not intended for use by clients.
# The location id of the Record or Row to be fetched.
      LOCATIONID => {:type => ::Thrift::Types::STRING, :name => 'locationId'},
      # The row id of the Row to be fetched, not to be used with location id.
      ROWID => {:type => ::Thrift::Types::STRING, :name => 'rowId'},
      # The record id of the Record to be fetched, not to be used with location id.  However the row id needs to be provided to locate the correct Row with the requested Record.
      RECORDID => {:type => ::Thrift::Types::STRING, :name => 'recordId'},
      # The column families to fetch. If null, fetch all. If empty, fetch none.
      COLUMNFAMILIESTOFETCH => {:type => ::Thrift::Types::SET, :name => 'columnFamiliesToFetch', :element => {:type => ::Thrift::Types::STRING}},
      # The columns in the families to fetch. If null, fetch all. If empty, fetch none.
      COLUMNSTOFETCH => {:type => ::Thrift::Types::MAP, :name => 'columnsToFetch', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::SET, :element => {:type => ::Thrift::Types::STRING}}},
      # Only valid for Row fetches, the record in the row to start fetching.  If the row contains 1000
# records and you want the first 100, then this value is 0.  If you want records 300-400 then this
# value would be 300.  If startRecord is beyond the end of the row, the row will be null in the
# FetchResult.  Used in conjunction with maxRecordsToFetch.
      STARTRECORD => {:type => ::Thrift::Types::I32, :name => 'startRecord', :default => 0},
      # Only valid for Row fetches, the number of records to fetch.  If the row contains 1000 records
# and you want the first 100, then this value is 100.  If you want records 300-400 then this value
# would be 100.  Used in conjunction with startRecord. By default this will fetch the first
# 1000 records of the row.
      MAXRECORDSTOFETCH => {:type => ::Thrift::Types::I32, :name => 'maxRecordsToFetch', :default => 1000},
      # The HighlightOptions object controls how the data is highlighted.  If null no highlighting will occur.
      HIGHLIGHTOPTIONS => {:type => ::Thrift::Types::STRUCT, :name => 'highlightOptions', :class => ::Blur::HighlightOptions},
      # Can be null, if provided the provided family order will be the order in which the families are returned.
      ORDEROFFAMILIESTOFETCH => {:type => ::Thrift::Types::LIST, :name => 'orderOfFamiliesToFetch', :element => {:type => ::Thrift::Types::STRING}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # FetchRowResult contains row result from a fetch.
  class FetchRowResult
    include ::Thrift::Struct, ::Thrift::Struct_Union
    ROW = 1
    STARTRECORD = 2
    MAXRECORDSTOFETCH = 3
    MORERECORDSTOFETCH = 4
    TOTALRECORDS = 5

    FIELDS = {
      # The row fetched.
      ROW => {:type => ::Thrift::Types::STRUCT, :name => 'row', :class => ::Blur::Row},
      # See Selector startRecord.
      STARTRECORD => {:type => ::Thrift::Types::I32, :name => 'startRecord', :default => -1},
      # See Selector maxRecordsToFetch.
      MAXRECORDSTOFETCH => {:type => ::Thrift::Types::I32, :name => 'maxRecordsToFetch', :default => -1},
      # Are there more Records to fetch based on the Selector provided.
      MORERECORDSTOFETCH => {:type => ::Thrift::Types::BOOL, :name => 'moreRecordsToFetch', :default => false},
      # The total number of records the Selector found.
      TOTALRECORDS => {:type => ::Thrift::Types::I32, :name => 'totalRecords'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # FetchRecordResult contains rowid of the record and the record result from a fetch.
  class FetchRecordResult
    include ::Thrift::Struct, ::Thrift::Struct_Union
    ROWID = 1
    RECORD = 2

    FIELDS = {
      # The row id of the record being fetched.
      ROWID => {:type => ::Thrift::Types::STRING, :name => 'rowid'},
      # The record fetched.
      RECORD => {:type => ::Thrift::Types::STRUCT, :name => 'record', :class => ::Blur::Record}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # FetchResult contains the row or record fetch result based if the Selector
# was going to fetch the entire row or a single record.
  class FetchResult
    include ::Thrift::Struct, ::Thrift::Struct_Union
    EXISTS = 1
    DELETED = 2
    TABLE = 3
    ROWRESULT = 4
    RECORDRESULT = 5

    FIELDS = {
      # True if the result exists, false if it doesn't.
      EXISTS => {:type => ::Thrift::Types::BOOL, :name => 'exists'},
      # If the row was marked as deleted.
      DELETED => {:type => ::Thrift::Types::BOOL, :name => 'deleted'},
      # The table the fetch result came from.
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      # The row result if a row was selected form the Selector.
      ROWRESULT => {:type => ::Thrift::Types::STRUCT, :name => 'rowResult', :class => ::Blur::FetchRowResult},
      # The record result if a record was selected form the Selector.
      RECORDRESULT => {:type => ::Thrift::Types::STRUCT, :name => 'recordResult', :class => ::Blur::FetchRecordResult}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # Blur facet.
  class Facet
    include ::Thrift::Struct, ::Thrift::Struct_Union
    QUERYSTR = 1
    MINIMUMNUMBEROFBLURRESULTS = 2

    FIELDS = {
      # The facet query.
      QUERYSTR => {:type => ::Thrift::Types::STRING, :name => 'queryStr'},
      # The minimum number of results before no longer processing the facet.  This
# is a good way to decrease the strain on the system while using many facets. For
# example if you set this attribute to 1000, then the shard server will stop
# processing the facet at the 1000 mark.  However because this is processed at
# the shard server level the controller will likely return more than the minimum
# because it sums the answers from the shard servers.
      MINIMUMNUMBEROFBLURRESULTS => {:type => ::Thrift::Types::I64, :name => 'minimumNumberOfBlurResults', :default => 9223372036854775807}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  class SortField
    include ::Thrift::Struct, ::Thrift::Struct_Union
    FAMILY = 1
    COLUMN = 2
    REVERSE = 3

    FIELDS = {
      FAMILY => {:type => ::Thrift::Types::STRING, :name => 'family'},
      COLUMN => {:type => ::Thrift::Types::STRING, :name => 'column'},
      REVERSE => {:type => ::Thrift::Types::BOOL, :name => 'reverse'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # The Blur Query object that contains the query that needs to be executed along
# with the query options.
  class BlurQuery
    include ::Thrift::Struct, ::Thrift::Struct_Union
    QUERY = 1
    FACETS = 3
    SELECTOR = 4
    USECACHEIFPRESENT = 6
    START = 7
    FETCH = 8
    MINIMUMNUMBEROFRESULTS = 9
    MAXQUERYTIME = 10
    UUID = 11
    USERCONTEXT = 12
    CACHERESULT = 13
    STARTTIME = 14
    SORTFIELDS = 15
    ROWID = 16

    FIELDS = {
      # The query information.
      QUERY => {:type => ::Thrift::Types::STRUCT, :name => 'query', :class => ::Blur::Query},
      # A list of Facets to execute with the given query.
      FACETS => {:type => ::Thrift::Types::LIST, :name => 'facets', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::Facet}},
      # Selector is used to fetch data in the search results, if null only location ids will be fetched.
      SELECTOR => {:type => ::Thrift::Types::STRUCT, :name => 'selector', :class => ::Blur::Selector},
      # Enabled by default to use a cached result if the query matches a previous run query with the
# configured amount of time.
      USECACHEIFPRESENT => {:type => ::Thrift::Types::BOOL, :name => 'useCacheIfPresent', :default => true},
      # The starting result position, 0 by default.
      START => {:type => ::Thrift::Types::I64, :name => 'start', :default => 0},
      # The number of fetched results, 10 by default.
      FETCH => {:type => ::Thrift::Types::I32, :name => 'fetch', :default => 10},
      # The minimum number of results to find before returning.
      MINIMUMNUMBEROFRESULTS => {:type => ::Thrift::Types::I64, :name => 'minimumNumberOfResults', :default => 9223372036854775807},
      # The maximum amount of time the query should execute before timing out.
      MAXQUERYTIME => {:type => ::Thrift::Types::I64, :name => 'maxQueryTime', :default => 9223372036854775807},
      # Sets the uuid of this query, this is normal set by the client so that the status
# of a running query can be found or the query can be canceled.
      UUID => {:type => ::Thrift::Types::STRING, :name => 'uuid'},
      # Sets a user context, only used for logging at this point.
# @Deprecated use setUser method on Blur service.
      USERCONTEXT => {:type => ::Thrift::Types::STRING, :name => 'userContext'},
      # Enabled by default to cache this result.  False would not cache the result.
      CACHERESULT => {:type => ::Thrift::Types::BOOL, :name => 'cacheResult', :default => true},
      # Sets the start time, if 0 the controller sets the time.
      STARTTIME => {:type => ::Thrift::Types::I64, :name => 'startTime', :default => 0},
      # The sortfields are applied in order to sort the results.
      SORTFIELDS => {:type => ::Thrift::Types::LIST, :name => 'sortFields', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::SortField}},
      # Optional optimization for record queries to run against a single row.  This will allow the query to be executed on one and only one shard in the cluster.
      ROWID => {:type => ::Thrift::Types::STRING, :name => 'rowId'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # Carries the one value from the sort that allows the merging of results.
  class SortFieldResult < ::Thrift::Union
    include ::Thrift::Struct_Union
    class << self
      def nullValue(val)
        SortFieldResult.new(:nullValue, val)
      end

      def stringValue(val)
        SortFieldResult.new(:stringValue, val)
      end

      def intValue(val)
        SortFieldResult.new(:intValue, val)
      end

      def longValue(val)
        SortFieldResult.new(:longValue, val)
      end

      def doubleValue(val)
        SortFieldResult.new(:doubleValue, val)
      end

      def binaryValue(val)
        SortFieldResult.new(:binaryValue, val)
      end
    end

    NULLVALUE = 1
    STRINGVALUE = 2
    INTVALUE = 3
    LONGVALUE = 4
    DOUBLEVALUE = 5
    BINARYVALUE = 6

    FIELDS = {
      # Carries the null boolean incase the field is null.
      NULLVALUE => {:type => ::Thrift::Types::BOOL, :name => 'nullValue'},
      # The string value.
      STRINGVALUE => {:type => ::Thrift::Types::STRING, :name => 'stringValue'},
      # The integer value.
      INTVALUE => {:type => ::Thrift::Types::I32, :name => 'intValue'},
      # The long value.
      LONGVALUE => {:type => ::Thrift::Types::I64, :name => 'longValue'},
      # The double value.
      DOUBLEVALUE => {:type => ::Thrift::Types::DOUBLE, :name => 'doubleValue'},
      # The binary value.
      BINARYVALUE => {:type => ::Thrift::Types::STRING, :name => 'binaryValue', :binary => true}
    }

    def struct_fields; FIELDS; end

    def validate
      raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
    end

    ::Thrift::Union.generate_accessors self
  end

  # The BlurResult carries the score, the location id and the fetched result (if any) form each query.
  class BlurResult
    include ::Thrift::Struct, ::Thrift::Struct_Union
    LOCATIONID = 1
    SCORE = 2
    FETCHRESULT = 3
    SORTFIELDRESULTS = 4

    FIELDS = {
      # WARNING: This is an internal only attribute and is not intended for use by clients.
      LOCATIONID => {:type => ::Thrift::Types::STRING, :name => 'locationId'},
      # The score for the hit in the query.
      SCORE => {:type => ::Thrift::Types::DOUBLE, :name => 'score'},
      # The fetched result if any.
      FETCHRESULT => {:type => ::Thrift::Types::STRUCT, :name => 'fetchResult', :class => ::Blur::FetchResult},
      # The fields used for sorting.
      SORTFIELDRESULTS => {:type => ::Thrift::Types::LIST, :name => 'sortFieldResults', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::SortFieldResult}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # BlurResults holds all information resulting from a query.
  class BlurResults
    include ::Thrift::Struct, ::Thrift::Struct_Union
    TOTALRESULTS = 1
    SHARDINFO = 2
    RESULTS = 3
    FACETCOUNTS = 4
    EXCEPTIONS = 5
    QUERY = 6

    FIELDS = {
      # The total number of hits in the query.
      TOTALRESULTS => {:type => ::Thrift::Types::I64, :name => 'totalResults', :default => 0},
      # Hit counts from each shard in the table.
      SHARDINFO => {:type => ::Thrift::Types::MAP, :name => 'shardInfo', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}},
      # The query results.
      RESULTS => {:type => ::Thrift::Types::LIST, :name => 'results', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::BlurResult}},
      # The faceted count.
      FACETCOUNTS => {:type => ::Thrift::Types::LIST, :name => 'facetCounts', :element => {:type => ::Thrift::Types::I64}},
      # Not currently used, a future feature could allow for partial results with errors.
      EXCEPTIONS => {:type => ::Thrift::Types::LIST, :name => 'exceptions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::BlurException}},
      # The original query.
      QUERY => {:type => ::Thrift::Types::STRUCT, :name => 'query', :class => ::Blur::BlurQuery}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # The RowMutation defines how the given Record is to be mutated.
  class RecordMutation
    include ::Thrift::Struct, ::Thrift::Struct_Union
    RECORDMUTATIONTYPE = 1
    RECORD = 2

    FIELDS = {
      # Define how to mutate the given Record.
      RECORDMUTATIONTYPE => {:type => ::Thrift::Types::I32, :name => 'recordMutationType', :default =>       1, :enum_class => ::Blur::RecordMutationType},
      # The Record to mutate.
      RECORD => {:type => ::Thrift::Types::STRUCT, :name => 'record', :class => ::Blur::Record}
    }

    def struct_fields; FIELDS; end

    def validate
      unless @recordMutationType.nil? || ::Blur::RecordMutationType::VALID_VALUES.include?(@recordMutationType)
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field recordMutationType!')
      end
    end

    ::Thrift::Struct.generate_accessors self
  end

  # The RowMutation defines how the given Row is to be mutated.
  class RowMutation
    include ::Thrift::Struct, ::Thrift::Struct_Union
    TABLE = 1
    ROWID = 2
    ROWMUTATIONTYPE = 4
    RECORDMUTATIONS = 5

    FIELDS = {
      # The table that the row mutation is to act upon.
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      # The row id that the row mutation is to act upon.
      ROWID => {:type => ::Thrift::Types::STRING, :name => 'rowId'},
      # The RowMutationType to define how to mutate the given Row.
      ROWMUTATIONTYPE => {:type => ::Thrift::Types::I32, :name => 'rowMutationType', :default =>       1, :enum_class => ::Blur::RowMutationType},
      # The RecordMutations if any for this Row.
      RECORDMUTATIONS => {:type => ::Thrift::Types::LIST, :name => 'recordMutations', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::RecordMutation}}
    }

    def struct_fields; FIELDS; end

    def validate
      unless @rowMutationType.nil? || ::Blur::RowMutationType::VALID_VALUES.include?(@rowMutationType)
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field rowMutationType!')
      end
    end

    ::Thrift::Struct.generate_accessors self
  end

  # Holds the cpu time for a query executing on a single shard in a table.
  class CpuTime
    include ::Thrift::Struct, ::Thrift::Struct_Union
    CPUTIME = 1
    REALTIME = 2

    FIELDS = {
      # The total cpu time for the query on the given shard.
      CPUTIME => {:type => ::Thrift::Types::I64, :name => 'cpuTime'},
      # The real time of the query execution for a given shard.
      REALTIME => {:type => ::Thrift::Types::I64, :name => 'realTime'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # The BlurQueryStatus object hold the status of BlurQueries.  The state of the query
# (QueryState), the number of shards the query is executing against, the number of
# shards that are complete, etc.
  class BlurQueryStatus
    include ::Thrift::Struct, ::Thrift::Struct_Union
    QUERY = 1
    CPUTIMES = 2
    COMPLETESHARDS = 3
    TOTALSHARDS = 4
    STATE = 5
    UUID = 6
    STATUS = 7
    USER = 8

    FIELDS = {
      # The original query.
      QUERY => {:type => ::Thrift::Types::STRUCT, :name => 'query', :class => ::Blur::BlurQuery},
      # A map of shard names to CpuTime, one for each shard in the table.
      CPUTIMES => {:type => ::Thrift::Types::MAP, :name => 'cpuTimes', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::CpuTime}},
      # The number of completed shards.  The shard server will respond with
# how many are complete on that server, while the controller will aggregate
# all the shard server completed totals together.
      COMPLETESHARDS => {:type => ::Thrift::Types::I32, :name => 'completeShards'},
      # The total number of shards that the query is executing against.  The shard
# server will respond with how many shards are being queried on that server, while
# the controller will aggregate all the shard server totals together.
      TOTALSHARDS => {:type => ::Thrift::Types::I32, :name => 'totalShards'},
      # The state of the query.  e.g. RUNNING, INTERRUPTED, COMPLETE
      STATE => {:type => ::Thrift::Types::I32, :name => 'state', :enum_class => ::Blur::QueryState},
      # The uuid of the query.
      UUID => {:type => ::Thrift::Types::STRING, :name => 'uuid'},
      # The status of the query NOT_FOUND if uuid is not found else FOUND
      STATUS => {:type => ::Thrift::Types::I32, :name => 'status', :enum_class => ::Blur::Status},
      # The user executing the given query.
      USER => {:type => ::Thrift::Types::STRUCT, :name => 'user', :class => ::Blur::User}
    }

    def struct_fields; FIELDS; end

    def validate
      unless @state.nil? || ::Blur::QueryState::VALID_VALUES.include?(@state)
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field state!')
      end
      unless @status.nil? || ::Blur::Status::VALID_VALUES.include?(@status)
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field status!')
      end
    end

    ::Thrift::Struct.generate_accessors self
  end

  # TableStats holds the statistics for a given table.
  class TableStats
    include ::Thrift::Struct, ::Thrift::Struct_Union
    TABLENAME = 1
    BYTES = 2
    RECORDCOUNT = 3
    ROWCOUNT = 4
    SEGMENTIMPORTPENDINGCOUNT = 5
    SEGMENTIMPORTINPROGRESSCOUNT = 6

    FIELDS = {
      # The table name.
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
      # The size in bytes.
      BYTES => {:type => ::Thrift::Types::I64, :name => 'bytes'},
      # The record count.
      RECORDCOUNT => {:type => ::Thrift::Types::I64, :name => 'recordCount'},
      # The row count.
      ROWCOUNT => {:type => ::Thrift::Types::I64, :name => 'rowCount'},
      # The number of pending segment imports for this table.
      SEGMENTIMPORTPENDINGCOUNT => {:type => ::Thrift::Types::I64, :name => 'segmentImportPendingCount', :default => 0},
      # The number of segment imports in progress for this table.
      SEGMENTIMPORTINPROGRESSCOUNT => {:type => ::Thrift::Types::I64, :name => 'segmentImportInProgressCount', :default => 0}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # The ColumnDefinition defines how a given Column should be interpreted (indexed/stored)
  class ColumnDefinition
    include ::Thrift::Struct, ::Thrift::Struct_Union
    FAMILY = 1
    COLUMNNAME = 2
    SUBCOLUMNNAME = 3
    FIELDLESSINDEXED = 4
    FIELDTYPE = 5
    PROPERTIES = 6
    SORTABLE = 7
    MULTIVALUEFIELD = 8

    FIELDS = {
      # Required. The family that this column exists within.
      FAMILY => {:type => ::Thrift::Types::STRING, :name => 'family'},
      # Required. The column name.
      COLUMNNAME => {:type => ::Thrift::Types::STRING, :name => 'columnName'},
      # If this column definition is for a sub column then provide the sub column name.  Otherwise leave this field null.
      SUBCOLUMNNAME => {:type => ::Thrift::Types::STRING, :name => 'subColumnName'},
      # If this column should be searchable without having to specify the name of the column in the query.
# NOTE: This will index the column as a full text field in a default field, so that means it's going to be indexed twice.
      FIELDLESSINDEXED => {:type => ::Thrift::Types::BOOL, :name => 'fieldLessIndexed'},
      # The field type for the column.  The built in types are:
# <ul>
# <li>text - Full text indexing.</li>
# <li>string - Indexed string literal</li>
# <li>int - Converted to an integer and indexed numerically.</li>
# <li>long - Converted to an long and indexed numerically.</li>
# <li>float - Converted to an float and indexed numerically.</li>
# <li>double - Converted to an double and indexed numerically.</li>
# <li>stored - Not indexed, only stored.</li>
# </ul>
      FIELDTYPE => {:type => ::Thrift::Types::STRING, :name => 'fieldType'},
      # For any custom field types, you can pass in configuration properties.
      PROPERTIES => {:type => ::Thrift::Types::MAP, :name => 'properties', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}},
      # This will attempt to enable sorting for this column, if the type does not support sorting then an exception will be thrown.
      SORTABLE => {:type => ::Thrift::Types::BOOL, :name => 'sortable'},
      # This will attempt to enable the ability for multiple values per column name in a single Record.
      MULTIVALUEFIELD => {:type => ::Thrift::Types::BOOL, :name => 'multiValueField', :default => true, :optional => true}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # The current schema of the table.
  class Schema
    include ::Thrift::Struct, ::Thrift::Struct_Union
    TABLE = 1
    FAMILIES = 2

    FIELDS = {
      # The table name.
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      # Families and the column definitions within them.
      FAMILIES => {:type => ::Thrift::Types::MAP, :name => 'families', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::ColumnDefinition}}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # The table descriptor defines the base structure of the table as well as properties need for setup.
  class TableDescriptor
    include ::Thrift::Struct, ::Thrift::Struct_Union
    ENABLED = 1
    SHARDCOUNT = 3
    TABLEURI = 4
    CLUSTER = 7
    NAME = 8
    SIMILARITYCLASS = 9
    BLOCKCACHING = 10
    BLOCKCACHINGFILETYPES = 11
    READONLY = 12
    PRECACHECOLS = 13
    TABLEPROPERTIES = 14
    STRICTTYPES = 15
    DEFAULTMISSINGFIELDTYPE = 16
    DEFAULTMISSINGFIELDLESSINDEXING = 17
    DEFAULTMISSINGFIELDPROPS = 18

    FIELDS = {
      # Is the table enabled or not, enabled by default.
      ENABLED => {:type => ::Thrift::Types::BOOL, :name => 'enabled', :default => true},
      # The number of shards within the given table.
      SHARDCOUNT => {:type => ::Thrift::Types::I32, :name => 'shardCount', :default => 1},
      # The location where the table should be stored this can be "file:///" for a local instance of Blur or "hdfs://" for a distributed installation of Blur.
      TABLEURI => {:type => ::Thrift::Types::STRING, :name => 'tableUri'},
      # The cluster where this table should be created.
      CLUSTER => {:type => ::Thrift::Types::STRING, :name => 'cluster', :default => %q"default"},
      # The table name.
      NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
      # Sets the similarity class in Lucene.
      SIMILARITYCLASS => {:type => ::Thrift::Types::STRING, :name => 'similarityClass'},
      # Should block cache be enable or disabled for this table.
      BLOCKCACHING => {:type => ::Thrift::Types::BOOL, :name => 'blockCaching', :default => true},
      # The files extensions that you would like to allow block cache to cache.  If null (default) everything is cached.
      BLOCKCACHINGFILETYPES => {:type => ::Thrift::Types::SET, :name => 'blockCachingFileTypes', :element => {:type => ::Thrift::Types::STRING}},
      # If a table is set to be readonly, that means that mutates through Thrift are NOT allowed.  However
# updates through MapReduce are allowed and in fact they are only allowed if the table is in readOnly mode.
      READONLY => {:type => ::Thrift::Types::BOOL, :name => 'readOnly', :default => false},
      # This is a list of fields to prefetch into the blockcache.  The format of the entries should
# be family dot column, "family.column".
      PRECACHECOLS => {:type => ::Thrift::Types::LIST, :name => 'preCacheCols', :element => {:type => ::Thrift::Types::STRING}},
      # The table properties that can modify the default behavior of the table.  TODO: Document all options.
      TABLEPROPERTIES => {:type => ::Thrift::Types::MAP, :name => 'tableProperties', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}},
      # Whether strict types are enabled or not (default).  If they are enabled no column can be added without first having it's type defined.
      STRICTTYPES => {:type => ::Thrift::Types::BOOL, :name => 'strictTypes', :default => false},
      # If strict is not enabled, the default field type.
      DEFAULTMISSINGFIELDTYPE => {:type => ::Thrift::Types::STRING, :name => 'defaultMissingFieldType', :default => %q"text"},
      # If strict is not enabled, defines whether or not field less indexing is enabled on the newly created fields.
      DEFAULTMISSINGFIELDLESSINDEXING => {:type => ::Thrift::Types::BOOL, :name => 'defaultMissingFieldLessIndexing', :default => true},
      # If strict is not enabled, defines the properties to be used in the new field creation.
      DEFAULTMISSINGFIELDPROPS => {:type => ::Thrift::Types::MAP, :name => 'defaultMissingFieldProps', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  # The Metric will hold all the information for a given Metric.
  class Metric
    include ::Thrift::Struct, ::Thrift::Struct_Union
    NAME = 1
    STRMAP = 2
    LONGMAP = 3
    DOUBLEMAP = 4

    FIELDS = {
      # metric name.
      NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
      # map of string values emitted by the Metric.
      STRMAP => {:type => ::Thrift::Types::MAP, :name => 'strMap', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}},
      # map of long values emitted by the Metric.
      LONGMAP => {:type => ::Thrift::Types::MAP, :name => 'longMap', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}},
      # map of double values emitted by the Metric.
      DOUBLEMAP => {:type => ::Thrift::Types::MAP, :name => 'doubleMap', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::DOUBLE}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  class Value < ::Thrift::Union
    include ::Thrift::Struct_Union
    class << self
      def stringValue(val)
        Value.new(:stringValue, val)
      end

      def intValue(val)
        Value.new(:intValue, val)
      end

      def shortValue(val)
        Value.new(:shortValue, val)
      end

      def longValue(val)
        Value.new(:longValue, val)
      end

      def doubleValue(val)
        Value.new(:doubleValue, val)
      end

      def floatValue(val)
        Value.new(:floatValue, val)
      end

      def binaryValue(val)
        Value.new(:binaryValue, val)
      end

      def booleanValue(val)
        Value.new(:booleanValue, val)
      end

      def nullValue(val)
        Value.new(:nullValue, val)
      end
    end

    STRINGVALUE = 1
    INTVALUE = 2
    SHORTVALUE = 3
    LONGVALUE = 4
    DOUBLEVALUE = 5
    FLOATVALUE = 6
    BINARYVALUE = 7
    BOOLEANVALUE = 8
    NULLVALUE = 9

    FIELDS = {
      STRINGVALUE => {:type => ::Thrift::Types::STRING, :name => 'stringValue'},
      INTVALUE => {:type => ::Thrift::Types::I32, :name => 'intValue'},
      SHORTVALUE => {:type => ::Thrift::Types::I16, :name => 'shortValue'},
      LONGVALUE => {:type => ::Thrift::Types::I64, :name => 'longValue'},
      DOUBLEVALUE => {:type => ::Thrift::Types::DOUBLE, :name => 'doubleValue'},
      FLOATVALUE => {:type => ::Thrift::Types::DOUBLE, :name => 'floatValue'},
      BINARYVALUE => {:type => ::Thrift::Types::STRING, :name => 'binaryValue', :binary => true},
      BOOLEANVALUE => {:type => ::Thrift::Types::BOOL, :name => 'booleanValue'},
      NULLVALUE => {:type => ::Thrift::Types::BOOL, :name => 'nullValue'}
    }

    def struct_fields; FIELDS; end

    def validate
      raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
    end

    ::Thrift::Union.generate_accessors self
  end

  class Shard
    include ::Thrift::Struct, ::Thrift::Struct_Union
    TABLE = 1
    SHARD = 2

    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      SHARD => {:type => ::Thrift::Types::STRING, :name => 'shard'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  class Server
    include ::Thrift::Struct, ::Thrift::Struct_Union
    SERVER = 1

    FIELDS = {
      SERVER => {:type => ::Thrift::Types::STRING, :name => 'server'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  class BlurPackedObject
    include ::Thrift::Struct, ::Thrift::Struct_Union
    PARENTID = 1
    TYPE = 2
    VALUE = 3

    FIELDS = {
      PARENTID => {:type => ::Thrift::Types::I32, :name => 'parentId'},
      TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::Blur::BlurObjectType},
      VALUE => {:type => ::Thrift::Types::STRUCT, :name => 'value', :class => ::Blur::Value}
    }

    def struct_fields; FIELDS; end

    def validate
      unless @type.nil? || ::Blur::BlurObjectType::VALID_VALUES.include?(@type)
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
      end
    end

    ::Thrift::Struct.generate_accessors self
  end

  class ValueObject < ::Thrift::Union
    include ::Thrift::Struct_Union
    class << self
      def value(val)
        ValueObject.new(:value, val)
      end

      def blurObject(val)
        ValueObject.new(:blurObject, val)
      end
    end

    VALUE = 1
    BLUROBJECT = 2

    FIELDS = {
      VALUE => {:type => ::Thrift::Types::STRUCT, :name => 'value', :class => ::Blur::Value},
      BLUROBJECT => {:type => ::Thrift::Types::LIST, :name => 'blurObject', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::BlurPackedObject}}
    }

    def struct_fields; FIELDS; end

    def validate
      raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
    end

    ::Thrift::Union.generate_accessors self
  end

  class Response < ::Thrift::Union
    include ::Thrift::Struct_Union
    class << self
      def shardToValue(val)
        Response.new(:shardToValue, val)
      end

      def serverToValue(val)
        Response.new(:serverToValue, val)
      end

      def value(val)
        Response.new(:value, val)
      end
    end

    SHARDTOVALUE = 1
    SERVERTOVALUE = 2
    VALUE = 3

    FIELDS = {
      SHARDTOVALUE => {:type => ::Thrift::Types::MAP, :name => 'shardToValue', :key => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::Shard}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::ValueObject}},
      SERVERTOVALUE => {:type => ::Thrift::Types::MAP, :name => 'serverToValue', :key => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::Server}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::ValueObject}},
      VALUE => {:type => ::Thrift::Types::STRUCT, :name => 'value', :class => ::Blur::ValueObject}
    }

    def struct_fields; FIELDS; end

    def validate
      raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
    end

    ::Thrift::Union.generate_accessors self
  end

  class Arguments
    include ::Thrift::Struct, ::Thrift::Struct_Union
    VALUES = 1

    FIELDS = {
      VALUES => {:type => ::Thrift::Types::MAP, :name => 'values', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::ValueObject}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  class CommandStatus
    include ::Thrift::Struct, ::Thrift::Struct_Union
    EXECUTIONID = 1
    TABLE = 2
    COMMANDNAME = 3
    ARGUMENTS = 4
    STATE = 5

    FIELDS = {
      EXECUTIONID => {:type => ::Thrift::Types::STRING, :name => 'executionId'},
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      COMMANDNAME => {:type => ::Thrift::Types::STRING, :name => 'commandName'},
      ARGUMENTS => {:type => ::Thrift::Types::STRUCT, :name => 'arguments', :class => ::Blur::Arguments},
      STATE => {:type => ::Thrift::Types::I32, :name => 'state', :enum_class => ::Blur::CommandStatusState}
    }

    def struct_fields; FIELDS; end

    def validate
      unless @state.nil? || ::Blur::CommandStatusState::VALID_VALUES.include?(@state)
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field state!')
      end
    end

    ::Thrift::Struct.generate_accessors self
  end

  class ArgumentDescriptor
    include ::Thrift::Struct, ::Thrift::Struct_Union
    NAME = 1
    TYPE = 2
    DESCRIPTION = 3

    FIELDS = {
      NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
      TYPE => {:type => ::Thrift::Types::STRING, :name => 'type'},
      DESCRIPTION => {:type => ::Thrift::Types::STRING, :name => 'description'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  class CommandDescriptor
    include ::Thrift::Struct, ::Thrift::Struct_Union
    COMMANDNAME = 1
    DESCRIPTION = 2
    REQUIREDARGUMENTS = 3
    OPTIONALARGUMENTS = 4
    RETURNTYPE = 5
    VERSION = 6

    FIELDS = {
      COMMANDNAME => {:type => ::Thrift::Types::STRING, :name => 'commandName'},
      DESCRIPTION => {:type => ::Thrift::Types::STRING, :name => 'description'},
      REQUIREDARGUMENTS => {:type => ::Thrift::Types::MAP, :name => 'requiredArguments', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::ArgumentDescriptor}},
      OPTIONALARGUMENTS => {:type => ::Thrift::Types::MAP, :name => 'optionalArguments', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Blur::ArgumentDescriptor}},
      RETURNTYPE => {:type => ::Thrift::Types::STRING, :name => 'returnType'},
      VERSION => {:type => ::Thrift::Types::STRING, :name => 'version'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

  class ShardOperationRequest
    include ::Thrift::Struct, ::Thrift::Struct_Union
    NAME = 1
    TABLE = 2
    SHARD = 3

    FIELDS = {
      NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      SHARD => {:type => ::Thrift::Types::STRING, :name => 'shard'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

    ::Thrift::Struct.generate_accessors self
  end

end
