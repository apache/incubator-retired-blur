#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Blur::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Blur::Blur_createTable_args;
use base qw(Class::Accessor);
Blur::Blur_createTable_args->mk_accessors( qw( tableDescriptor ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableDescriptor} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableDescriptor}) {
      $self->{tableDescriptor} = $vals->{tableDescriptor};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_createTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tableDescriptor} = new Blur::TableDescriptor();
        $xfer += $self->{tableDescriptor}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_createTable_args');
  if (defined $self->{tableDescriptor}) {
    $xfer += $output->writeFieldBegin('tableDescriptor', TType::STRUCT, 1);
    $xfer += $self->{tableDescriptor}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_createTable_result;
use base qw(Class::Accessor);
Blur::Blur_createTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_createTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_createTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_enableTable_args;
use base qw(Class::Accessor);
Blur::Blur_enableTable_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_enableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_enableTable_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_enableTable_result;
use base qw(Class::Accessor);
Blur::Blur_enableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_enableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_enableTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_disableTable_args;
use base qw(Class::Accessor);
Blur::Blur_disableTable_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_disableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_disableTable_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_disableTable_result;
use base qw(Class::Accessor);
Blur::Blur_disableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_disableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_disableTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_removeTable_args;
use base qw(Class::Accessor);
Blur::Blur_removeTable_args->mk_accessors( qw( table deleteIndexFiles ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{deleteIndexFiles} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{deleteIndexFiles}) {
      $self->{deleteIndexFiles} = $vals->{deleteIndexFiles};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_removeTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteIndexFiles});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_removeTable_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteIndexFiles}) {
    $xfer += $output->writeFieldBegin('deleteIndexFiles', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{deleteIndexFiles});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_removeTable_result;
use base qw(Class::Accessor);
Blur::Blur_removeTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_removeTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_removeTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_addColumnDefinition_args;
use base qw(Class::Accessor);
Blur::Blur_addColumnDefinition_args->mk_accessors( qw( table columnDefinition ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnDefinition} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnDefinition}) {
      $self->{columnDefinition} = $vals->{columnDefinition};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_addColumnDefinition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{columnDefinition} = new Blur::ColumnDefinition();
        $xfer += $self->{columnDefinition}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_addColumnDefinition_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnDefinition}) {
    $xfer += $output->writeFieldBegin('columnDefinition', TType::STRUCT, 2);
    $xfer += $self->{columnDefinition}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_addColumnDefinition_result;
use base qw(Class::Accessor);
Blur::Blur_addColumnDefinition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_addColumnDefinition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_addColumnDefinition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableList_result;
use base qw(Class::Accessor);
Blur::Blur_tableList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size185 = 0;
          $self->{success} = [];
          my $_etype188 = 0;
          $xfer += $input->readListBegin(\$_etype188, \$_size185);
          for (my $_i189 = 0; $_i189 < $_size185; ++$_i189)
          {
            my $elem190 = undef;
            $xfer += $input->readString(\$elem190);
            push(@{$self->{success}},$elem190);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter191 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter191);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableListByCluster_args;
use base qw(Class::Accessor);
Blur::Blur_tableListByCluster_args->mk_accessors( qw( cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableListByCluster_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableListByCluster_args');
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 1);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableListByCluster_result;
use base qw(Class::Accessor);
Blur::Blur_tableListByCluster_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableListByCluster_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size192 = 0;
          $self->{success} = [];
          my $_etype195 = 0;
          $xfer += $input->readListBegin(\$_etype195, \$_size192);
          for (my $_i196 = 0; $_i196 < $_size192; ++$_i196)
          {
            my $elem197 = undef;
            $xfer += $input->readString(\$elem197);
            push(@{$self->{success}},$elem197);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableListByCluster_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter198 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter198);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_describe_args;
use base qw(Class::Accessor);
Blur::Blur_describe_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_describe_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_describe_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_describe_result;
use base qw(Class::Accessor);
Blur::Blur_describe_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_describe_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::TableDescriptor();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_describe_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_schema_args;
use base qw(Class::Accessor);
Blur::Blur_schema_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_schema_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_schema_result;
use base qw(Class::Accessor);
Blur::Blur_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::Schema();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_parseQuery_args;
use base qw(Class::Accessor);
Blur::Blur_parseQuery_args->mk_accessors( qw( table query ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{query} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_parseQuery_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::Query();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_parseQuery_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 2);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_parseQuery_result;
use base qw(Class::Accessor);
Blur::Blur_parseQuery_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_parseQuery_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_parseQuery_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableStats_args;
use base qw(Class::Accessor);
Blur::Blur_tableStats_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableStats_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableStats_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableStats_result;
use base qw(Class::Accessor);
Blur::Blur_tableStats_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableStats_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::TableStats();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableStats_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_optimize_args;
use base qw(Class::Accessor);
Blur::Blur_optimize_args->mk_accessors( qw( table numberOfSegmentsPerShard ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{numberOfSegmentsPerShard} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{numberOfSegmentsPerShard}) {
      $self->{numberOfSegmentsPerShard} = $vals->{numberOfSegmentsPerShard};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_optimize_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{numberOfSegmentsPerShard});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_optimize_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numberOfSegmentsPerShard}) {
    $xfer += $output->writeFieldBegin('numberOfSegmentsPerShard', TType::I32, 2);
    $xfer += $output->writeI32($self->{numberOfSegmentsPerShard});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_optimize_result;
use base qw(Class::Accessor);
Blur::Blur_optimize_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_optimize_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_optimize_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_createSnapshot_args;
use base qw(Class::Accessor);
Blur::Blur_createSnapshot_args->mk_accessors( qw( table name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_createSnapshot_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_createSnapshot_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_createSnapshot_result;
use base qw(Class::Accessor);
Blur::Blur_createSnapshot_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_createSnapshot_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_createSnapshot_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_removeSnapshot_args;
use base qw(Class::Accessor);
Blur::Blur_removeSnapshot_args->mk_accessors( qw( table name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_removeSnapshot_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_removeSnapshot_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_removeSnapshot_result;
use base qw(Class::Accessor);
Blur::Blur_removeSnapshot_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_removeSnapshot_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_removeSnapshot_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_listSnapshots_args;
use base qw(Class::Accessor);
Blur::Blur_listSnapshots_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_listSnapshots_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_listSnapshots_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_listSnapshots_result;
use base qw(Class::Accessor);
Blur::Blur_listSnapshots_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_listSnapshots_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size199 = 0;
          $self->{success} = {};
          my $_ktype200 = 0;
          my $_vtype201 = 0;
          $xfer += $input->readMapBegin(\$_ktype200, \$_vtype201, \$_size199);
          for (my $_i203 = 0; $_i203 < $_size199; ++$_i203)
          {
            my $key204 = '';
            my $val205 = [];
            $xfer += $input->readString(\$key204);
            {
              my $_size206 = 0;
              $val205 = [];
              my $_etype209 = 0;
              $xfer += $input->readListBegin(\$_etype209, \$_size206);
              for (my $_i210 = 0; $_i210 < $_size206; ++$_i210)
              {
                my $elem211 = undef;
                $xfer += $input->readString(\$elem211);
                push(@{$val205},$elem211);
              }
              $xfer += $input->readListEnd();
            }
            $self->{success}->{$key204} = $val205;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_listSnapshots_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter212,$viter213) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter212);
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${viter213}}));
            {
              foreach my $iter214 (@{${viter213}}) 
              {
                $xfer += $output->writeString($iter214);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_setUser_args;
use base qw(Class::Accessor);
Blur::Blur_setUser_args->mk_accessors( qw( user ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{user} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{user}) {
      $self->{user} = $vals->{user};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_setUser_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{user} = new Blur::User();
        $xfer += $self->{user}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_setUser_args');
  if (defined $self->{user}) {
    $xfer += $output->writeFieldBegin('user', TType::STRUCT, 1);
    $xfer += $self->{user}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_setUser_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_setUser_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_setUser_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_query_args;
use base qw(Class::Accessor);
Blur::Blur_query_args->mk_accessors( qw( table blurQuery ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{blurQuery} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{blurQuery}) {
      $self->{blurQuery} = $vals->{blurQuery};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{blurQuery} = new Blur::BlurQuery();
        $xfer += $self->{blurQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_query_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blurQuery}) {
    $xfer += $output->writeFieldBegin('blurQuery', TType::STRUCT, 2);
    $xfer += $self->{blurQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_query_result;
use base qw(Class::Accessor);
Blur::Blur_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::BlurResults();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_fetchRow_args;
use base qw(Class::Accessor);
Blur::Blur_fetchRow_args->mk_accessors( qw( table selector ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{selector} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{selector}) {
      $self->{selector} = $vals->{selector};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_fetchRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{selector} = new Blur::Selector();
        $xfer += $self->{selector}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_fetchRow_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{selector}) {
    $xfer += $output->writeFieldBegin('selector', TType::STRUCT, 2);
    $xfer += $self->{selector}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_fetchRow_result;
use base qw(Class::Accessor);
Blur::Blur_fetchRow_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_fetchRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::FetchResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_fetchRow_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_fetchRowBatch_args;
use base qw(Class::Accessor);
Blur::Blur_fetchRowBatch_args->mk_accessors( qw( table selectors ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{selectors} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{selectors}) {
      $self->{selectors} = $vals->{selectors};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_fetchRowBatch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size215 = 0;
          $self->{selectors} = [];
          my $_etype218 = 0;
          $xfer += $input->readListBegin(\$_etype218, \$_size215);
          for (my $_i219 = 0; $_i219 < $_size215; ++$_i219)
          {
            my $elem220 = undef;
            $elem220 = new Blur::Selector();
            $xfer += $elem220->read($input);
            push(@{$self->{selectors}},$elem220);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_fetchRowBatch_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{selectors}) {
    $xfer += $output->writeFieldBegin('selectors', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{selectors}}));
      {
        foreach my $iter221 (@{$self->{selectors}}) 
        {
          $xfer += ${iter221}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_fetchRowBatch_result;
use base qw(Class::Accessor);
Blur::Blur_fetchRowBatch_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_fetchRowBatch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size222 = 0;
          $self->{success} = [];
          my $_etype225 = 0;
          $xfer += $input->readListBegin(\$_etype225, \$_size222);
          for (my $_i226 = 0; $_i226 < $_size222; ++$_i226)
          {
            my $elem227 = undef;
            $elem227 = new Blur::FetchResult();
            $xfer += $elem227->read($input);
            push(@{$self->{success}},$elem227);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_fetchRowBatch_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter228 (@{$self->{success}}) 
        {
          $xfer += ${iter228}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutate_args;
use base qw(Class::Accessor);
Blur::Blur_mutate_args->mk_accessors( qw( mutation ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutation} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutation}) {
      $self->{mutation} = $vals->{mutation};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutation} = new Blur::RowMutation();
        $xfer += $self->{mutation}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutate_args');
  if (defined $self->{mutation}) {
    $xfer += $output->writeFieldBegin('mutation', TType::STRUCT, 1);
    $xfer += $self->{mutation}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutate_result;
use base qw(Class::Accessor);
Blur::Blur_mutate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutate_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutateBatch_args;
use base qw(Class::Accessor);
Blur::Blur_mutateBatch_args->mk_accessors( qw( mutations ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutations} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutations}) {
      $self->{mutations} = $vals->{mutations};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutateBatch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size229 = 0;
          $self->{mutations} = [];
          my $_etype232 = 0;
          $xfer += $input->readListBegin(\$_etype232, \$_size229);
          for (my $_i233 = 0; $_i233 < $_size229; ++$_i233)
          {
            my $elem234 = undef;
            $elem234 = new Blur::RowMutation();
            $xfer += $elem234->read($input);
            push(@{$self->{mutations}},$elem234);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutateBatch_args');
  if (defined $self->{mutations}) {
    $xfer += $output->writeFieldBegin('mutations', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{mutations}}));
      {
        foreach my $iter235 (@{$self->{mutations}}) 
        {
          $xfer += ${iter235}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutateBatch_result;
use base qw(Class::Accessor);
Blur::Blur_mutateBatch_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutateBatch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutateBatch_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_cancelQuery_args;
use base qw(Class::Accessor);
Blur::Blur_cancelQuery_args->mk_accessors( qw( table uuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{uuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_cancelQuery_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_cancelQuery_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::STRING, 2);
    $xfer += $output->writeString($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_cancelQuery_result;
use base qw(Class::Accessor);
Blur::Blur_cancelQuery_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_cancelQuery_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_cancelQuery_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusIdList_args;
use base qw(Class::Accessor);
Blur::Blur_queryStatusIdList_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusIdList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusIdList_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusIdList_result;
use base qw(Class::Accessor);
Blur::Blur_queryStatusIdList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusIdList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size236 = 0;
          $self->{success} = [];
          my $_etype239 = 0;
          $xfer += $input->readListBegin(\$_etype239, \$_size236);
          for (my $_i240 = 0; $_i240 < $_size236; ++$_i240)
          {
            my $elem241 = undef;
            $xfer += $input->readString(\$elem241);
            push(@{$self->{success}},$elem241);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusIdList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter242 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter242);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusById_args;
use base qw(Class::Accessor);
Blur::Blur_queryStatusById_args->mk_accessors( qw( table uuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{uuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusById_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusById_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::STRING, 2);
    $xfer += $output->writeString($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusById_result;
use base qw(Class::Accessor);
Blur::Blur_queryStatusById_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusById_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::BlurQueryStatus();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusById_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_terms_args;
use base qw(Class::Accessor);
Blur::Blur_terms_args->mk_accessors( qw( table columnFamily columnName startWith size ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnFamily} = undef;
  $self->{columnName} = undef;
  $self->{startWith} = undef;
  $self->{size} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnFamily}) {
      $self->{columnFamily} = $vals->{columnFamily};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
    if (defined $vals->{startWith}) {
      $self->{startWith} = $vals->{startWith};
    }
    if (defined $vals->{size}) {
      $self->{size} = $vals->{size};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_terms_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnFamily});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startWith});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_terms_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamily}) {
    $xfer += $output->writeFieldBegin('columnFamily', TType::STRING, 2);
    $xfer += $output->writeString($self->{columnFamily});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 3);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startWith}) {
    $xfer += $output->writeFieldBegin('startWith', TType::STRING, 4);
    $xfer += $output->writeString($self->{startWith});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{size}) {
    $xfer += $output->writeFieldBegin('size', TType::I16, 5);
    $xfer += $output->writeI16($self->{size});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_terms_result;
use base qw(Class::Accessor);
Blur::Blur_terms_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_terms_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size243 = 0;
          $self->{success} = [];
          my $_etype246 = 0;
          $xfer += $input->readListBegin(\$_etype246, \$_size243);
          for (my $_i247 = 0; $_i247 < $_size243; ++$_i247)
          {
            my $elem248 = undef;
            $xfer += $input->readString(\$elem248);
            push(@{$self->{success}},$elem248);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_terms_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter249 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter249);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_recordFrequency_args;
use base qw(Class::Accessor);
Blur::Blur_recordFrequency_args->mk_accessors( qw( table columnFamily columnName value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnFamily} = undef;
  $self->{columnName} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnFamily}) {
      $self->{columnFamily} = $vals->{columnFamily};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_recordFrequency_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnFamily});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_recordFrequency_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamily}) {
    $xfer += $output->writeFieldBegin('columnFamily', TType::STRING, 2);
    $xfer += $output->writeString($self->{columnFamily});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 3);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_recordFrequency_result;
use base qw(Class::Accessor);
Blur::Blur_recordFrequency_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_recordFrequency_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_recordFrequency_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardClusterList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardClusterList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardClusterList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardClusterList_result;
use base qw(Class::Accessor);
Blur::Blur_shardClusterList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardClusterList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size250 = 0;
          $self->{success} = [];
          my $_etype253 = 0;
          $xfer += $input->readListBegin(\$_etype253, \$_size250);
          for (my $_i254 = 0; $_i254 < $_size250; ++$_i254)
          {
            my $elem255 = undef;
            $xfer += $input->readString(\$elem255);
            push(@{$self->{success}},$elem255);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardClusterList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter256 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter256);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerList_args;
use base qw(Class::Accessor);
Blur::Blur_shardServerList_args->mk_accessors( qw( cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerList_args');
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 1);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerList_result;
use base qw(Class::Accessor);
Blur::Blur_shardServerList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size257 = 0;
          $self->{success} = [];
          my $_etype260 = 0;
          $xfer += $input->readListBegin(\$_etype260, \$_size257);
          for (my $_i261 = 0; $_i261 < $_size257; ++$_i261)
          {
            my $elem262 = undef;
            $xfer += $input->readString(\$elem262);
            push(@{$self->{success}},$elem262);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter263 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter263);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_controllerServerList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_controllerServerList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_controllerServerList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_controllerServerList_result;
use base qw(Class::Accessor);
Blur::Blur_controllerServerList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_controllerServerList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size264 = 0;
          $self->{success} = [];
          my $_etype267 = 0;
          $xfer += $input->readListBegin(\$_etype267, \$_size264);
          for (my $_i268 = 0; $_i268 < $_size264; ++$_i268)
          {
            my $elem269 = undef;
            $xfer += $input->readString(\$elem269);
            push(@{$self->{success}},$elem269);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_controllerServerList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter270 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter270);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayout_args;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayout_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayout_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayout_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayout_result;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayout_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayout_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size271 = 0;
          $self->{success} = {};
          my $_ktype272 = 0;
          my $_vtype273 = 0;
          $xfer += $input->readMapBegin(\$_ktype272, \$_vtype273, \$_size271);
          for (my $_i275 = 0; $_i275 < $_size271; ++$_i275)
          {
            my $key276 = '';
            my $val277 = '';
            $xfer += $input->readString(\$key276);
            $xfer += $input->readString(\$val277);
            $self->{success}->{$key276} = $val277;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayout_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter278,$viter279) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter278);
          $xfer += $output->writeString($viter279);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayoutState_args;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayoutState_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayoutState_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayoutState_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayoutState_result;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayoutState_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayoutState_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size280 = 0;
          $self->{success} = {};
          my $_ktype281 = 0;
          my $_vtype282 = 0;
          $xfer += $input->readMapBegin(\$_ktype281, \$_vtype282, \$_size280);
          for (my $_i284 = 0; $_i284 < $_size280; ++$_i284)
          {
            my $key285 = '';
            my $val286 = [];
            $xfer += $input->readString(\$key285);
            {
              my $_size287 = 0;
              $val286 = {};
              my $_ktype288 = 0;
              my $_vtype289 = 0;
              $xfer += $input->readMapBegin(\$_ktype288, \$_vtype289, \$_size287);
              for (my $_i291 = 0; $_i291 < $_size287; ++$_i291)
              {
                my $key292 = '';
                my $val293 = 0;
                $xfer += $input->readString(\$key292);
                $xfer += $input->readI32(\$val293);
                $val286->{$key292} = $val293;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{success}->{$key285} = $val286;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayoutState_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::MAP, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter294,$viter295) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter294);
          {
            $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{${viter295}}));
            {
              while( my ($kiter296,$viter297) = each %{${viter295}}) 
              {
                $xfer += $output->writeString($kiter296);
                $xfer += $output->writeI32($viter297);
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_isInSafeMode_args;
use base qw(Class::Accessor);
Blur::Blur_isInSafeMode_args->mk_accessors( qw( cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_isInSafeMode_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_isInSafeMode_args');
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 1);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_isInSafeMode_result;
use base qw(Class::Accessor);
Blur::Blur_isInSafeMode_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_isInSafeMode_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_isInSafeMode_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_configuration_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_configuration_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_configuration_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_configuration_result;
use base qw(Class::Accessor);
Blur::Blur_configuration_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_configuration_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size298 = 0;
          $self->{success} = {};
          my $_ktype299 = 0;
          my $_vtype300 = 0;
          $xfer += $input->readMapBegin(\$_ktype299, \$_vtype300, \$_size298);
          for (my $_i302 = 0; $_i302 < $_size298; ++$_i302)
          {
            my $key303 = '';
            my $val304 = '';
            $xfer += $input->readString(\$key303);
            $xfer += $input->readString(\$val304);
            $self->{success}->{$key303} = $val304;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_configuration_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter305,$viter306) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter305);
          $xfer += $output->writeString($viter306);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_metrics_args;
use base qw(Class::Accessor);
Blur::Blur_metrics_args->mk_accessors( qw( metrics ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{metrics} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{metrics}) {
      $self->{metrics} = $vals->{metrics};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_metrics_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size307 = 0;
          $self->{metrics} = {};
          my $_etype310 = 0;
          $xfer += $input->readSetBegin(\$_etype310, \$_size307);
          for (my $_i311 = 0; $_i311 < $_size307; ++$_i311)
          {
            my $elem312 = undef;
            $xfer += $input->readString(\$elem312);
            $self->{metrics}->{$elem312} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_metrics_args');
  if (defined $self->{metrics}) {
    $xfer += $output->writeFieldBegin('metrics', TType::SET, 1);
    {
      $xfer += $output->writeSetBegin(TType::STRING, scalar(@{$self->{metrics}}));
      {
        foreach my $iter313 (@{$self->{metrics}})
        {
          $xfer += $output->writeString($iter313);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_metrics_result;
use base qw(Class::Accessor);
Blur::Blur_metrics_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_metrics_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size314 = 0;
          $self->{success} = {};
          my $_ktype315 = 0;
          my $_vtype316 = 0;
          $xfer += $input->readMapBegin(\$_ktype315, \$_vtype316, \$_size314);
          for (my $_i318 = 0; $_i318 < $_size314; ++$_i318)
          {
            my $key319 = '';
            my $val320 = new Blur::Metric();
            $xfer += $input->readString(\$key319);
            $val320 = new Blur::Metric();
            $xfer += $val320->read($input);
            $self->{success}->{$key319} = $val320;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_metrics_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter321,$viter322) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter321);
          $xfer += ${viter322}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_startTrace_args;
use base qw(Class::Accessor);
Blur::Blur_startTrace_args->mk_accessors( qw( traceId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{traceId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{traceId}) {
      $self->{traceId} = $vals->{traceId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_startTrace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{traceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_startTrace_args');
  if (defined $self->{traceId}) {
    $xfer += $output->writeFieldBegin('traceId', TType::STRING, 1);
    $xfer += $output->writeString($self->{traceId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_startTrace_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_startTrace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_startTrace_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurIf;

use strict;


sub createTable{
  my $self = shift;
  my $tableDescriptor = shift;

  die 'implement interface';
}

sub enableTable{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub disableTable{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub removeTable{
  my $self = shift;
  my $table = shift;
  my $deleteIndexFiles = shift;

  die 'implement interface';
}

sub addColumnDefinition{
  my $self = shift;
  my $table = shift;
  my $columnDefinition = shift;

  die 'implement interface';
}

sub tableList{
  my $self = shift;

  die 'implement interface';
}

sub tableListByCluster{
  my $self = shift;
  my $cluster = shift;

  die 'implement interface';
}

sub describe{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub schema{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub parseQuery{
  my $self = shift;
  my $table = shift;
  my $query = shift;

  die 'implement interface';
}

sub tableStats{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub optimize{
  my $self = shift;
  my $table = shift;
  my $numberOfSegmentsPerShard = shift;

  die 'implement interface';
}

sub createSnapshot{
  my $self = shift;
  my $table = shift;
  my $name = shift;

  die 'implement interface';
}

sub removeSnapshot{
  my $self = shift;
  my $table = shift;
  my $name = shift;

  die 'implement interface';
}

sub listSnapshots{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub setUser{
  my $self = shift;
  my $user = shift;

  die 'implement interface';
}

sub query{
  my $self = shift;
  my $table = shift;
  my $blurQuery = shift;

  die 'implement interface';
}

sub fetchRow{
  my $self = shift;
  my $table = shift;
  my $selector = shift;

  die 'implement interface';
}

sub fetchRowBatch{
  my $self = shift;
  my $table = shift;
  my $selectors = shift;

  die 'implement interface';
}

sub mutate{
  my $self = shift;
  my $mutation = shift;

  die 'implement interface';
}

sub mutateBatch{
  my $self = shift;
  my $mutations = shift;

  die 'implement interface';
}

sub cancelQuery{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  die 'implement interface';
}

sub queryStatusIdList{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub queryStatusById{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  die 'implement interface';
}

sub terms{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $startWith = shift;
  my $size = shift;

  die 'implement interface';
}

sub recordFrequency{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $value = shift;

  die 'implement interface';
}

sub shardClusterList{
  my $self = shift;

  die 'implement interface';
}

sub shardServerList{
  my $self = shift;
  my $cluster = shift;

  die 'implement interface';
}

sub controllerServerList{
  my $self = shift;

  die 'implement interface';
}

sub shardServerLayout{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub shardServerLayoutState{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub isInSafeMode{
  my $self = shift;
  my $cluster = shift;

  die 'implement interface';
}

sub configuration{
  my $self = shift;

  die 'implement interface';
}

sub metrics{
  my $self = shift;
  my $metrics = shift;

  die 'implement interface';
}

sub startTrace{
  my $self = shift;
  my $traceId = shift;

  die 'implement interface';
}

package Blur::BlurRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub createTable{
  my ($self, $request) = @_;

  my $tableDescriptor = ($request->{'tableDescriptor'}) ? $request->{'tableDescriptor'} : undef;
  return $self->{impl}->createTable($tableDescriptor);
}

sub enableTable{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->enableTable($table);
}

sub disableTable{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->disableTable($table);
}

sub removeTable{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $deleteIndexFiles = ($request->{'deleteIndexFiles'}) ? $request->{'deleteIndexFiles'} : undef;
  return $self->{impl}->removeTable($table, $deleteIndexFiles);
}

sub addColumnDefinition{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $columnDefinition = ($request->{'columnDefinition'}) ? $request->{'columnDefinition'} : undef;
  return $self->{impl}->addColumnDefinition($table, $columnDefinition);
}

sub tableList{
  my ($self, $request) = @_;

  return $self->{impl}->tableList();
}

sub tableListByCluster{
  my ($self, $request) = @_;

  my $cluster = ($request->{'cluster'}) ? $request->{'cluster'} : undef;
  return $self->{impl}->tableListByCluster($cluster);
}

sub describe{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->describe($table);
}

sub schema{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->schema($table);
}

sub parseQuery{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  return $self->{impl}->parseQuery($table, $query);
}

sub tableStats{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->tableStats($table);
}

sub optimize{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $numberOfSegmentsPerShard = ($request->{'numberOfSegmentsPerShard'}) ? $request->{'numberOfSegmentsPerShard'} : undef;
  return $self->{impl}->optimize($table, $numberOfSegmentsPerShard);
}

sub createSnapshot{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->createSnapshot($table, $name);
}

sub removeSnapshot{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->removeSnapshot($table, $name);
}

sub listSnapshots{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->listSnapshots($table);
}

sub setUser{
  my ($self, $request) = @_;

  my $user = ($request->{'user'}) ? $request->{'user'} : undef;
  return $self->{impl}->setUser($user);
}

sub query{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $blurQuery = ($request->{'blurQuery'}) ? $request->{'blurQuery'} : undef;
  return $self->{impl}->query($table, $blurQuery);
}

sub fetchRow{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $selector = ($request->{'selector'}) ? $request->{'selector'} : undef;
  return $self->{impl}->fetchRow($table, $selector);
}

sub fetchRowBatch{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $selectors = ($request->{'selectors'}) ? $request->{'selectors'} : undef;
  return $self->{impl}->fetchRowBatch($table, $selectors);
}

sub mutate{
  my ($self, $request) = @_;

  my $mutation = ($request->{'mutation'}) ? $request->{'mutation'} : undef;
  return $self->{impl}->mutate($mutation);
}

sub mutateBatch{
  my ($self, $request) = @_;

  my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
  return $self->{impl}->mutateBatch($mutations);
}

sub cancelQuery{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $uuid = ($request->{'uuid'}) ? $request->{'uuid'} : undef;
  return $self->{impl}->cancelQuery($table, $uuid);
}

sub queryStatusIdList{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->queryStatusIdList($table);
}

sub queryStatusById{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $uuid = ($request->{'uuid'}) ? $request->{'uuid'} : undef;
  return $self->{impl}->queryStatusById($table, $uuid);
}

sub terms{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $columnFamily = ($request->{'columnFamily'}) ? $request->{'columnFamily'} : undef;
  my $columnName = ($request->{'columnName'}) ? $request->{'columnName'} : undef;
  my $startWith = ($request->{'startWith'}) ? $request->{'startWith'} : undef;
  my $size = ($request->{'size'}) ? $request->{'size'} : undef;
  return $self->{impl}->terms($table, $columnFamily, $columnName, $startWith, $size);
}

sub recordFrequency{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $columnFamily = ($request->{'columnFamily'}) ? $request->{'columnFamily'} : undef;
  my $columnName = ($request->{'columnName'}) ? $request->{'columnName'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  return $self->{impl}->recordFrequency($table, $columnFamily, $columnName, $value);
}

sub shardClusterList{
  my ($self, $request) = @_;

  return $self->{impl}->shardClusterList();
}

sub shardServerList{
  my ($self, $request) = @_;

  my $cluster = ($request->{'cluster'}) ? $request->{'cluster'} : undef;
  return $self->{impl}->shardServerList($cluster);
}

sub controllerServerList{
  my ($self, $request) = @_;

  return $self->{impl}->controllerServerList();
}

sub shardServerLayout{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->shardServerLayout($table);
}

sub shardServerLayoutState{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->shardServerLayoutState($table);
}

sub isInSafeMode{
  my ($self, $request) = @_;

  my $cluster = ($request->{'cluster'}) ? $request->{'cluster'} : undef;
  return $self->{impl}->isInSafeMode($cluster);
}

sub configuration{
  my ($self, $request) = @_;

  return $self->{impl}->configuration();
}

sub metrics{
  my ($self, $request) = @_;

  my $metrics = ($request->{'metrics'}) ? $request->{'metrics'} : undef;
  return $self->{impl}->metrics($metrics);
}

sub startTrace{
  my ($self, $request) = @_;

  my $traceId = ($request->{'traceId'}) ? $request->{'traceId'} : undef;
  return $self->{impl}->startTrace($traceId);
}

package Blur::BlurClient;


use base qw(Blur::BlurIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub createTable{
  my $self = shift;
  my $tableDescriptor = shift;

    $self->send_createTable($tableDescriptor);
  $self->recv_createTable();
}

sub send_createTable{
  my $self = shift;
  my $tableDescriptor = shift;

  $self->{output}->writeMessageBegin('createTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_createTable_args();
  $args->{tableDescriptor} = $tableDescriptor;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_createTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub enableTable{
  my $self = shift;
  my $table = shift;

    $self->send_enableTable($table);
  $self->recv_enableTable();
}

sub send_enableTable{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('enableTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_enableTable_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_enableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_enableTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub disableTable{
  my $self = shift;
  my $table = shift;

    $self->send_disableTable($table);
  $self->recv_disableTable();
}

sub send_disableTable{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('disableTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_disableTable_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_disableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_disableTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub removeTable{
  my $self = shift;
  my $table = shift;
  my $deleteIndexFiles = shift;

    $self->send_removeTable($table, $deleteIndexFiles);
  $self->recv_removeTable();
}

sub send_removeTable{
  my $self = shift;
  my $table = shift;
  my $deleteIndexFiles = shift;

  $self->{output}->writeMessageBegin('removeTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_removeTable_args();
  $args->{table} = $table;
  $args->{deleteIndexFiles} = $deleteIndexFiles;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_removeTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_removeTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub addColumnDefinition{
  my $self = shift;
  my $table = shift;
  my $columnDefinition = shift;

    $self->send_addColumnDefinition($table, $columnDefinition);
  return $self->recv_addColumnDefinition();
}

sub send_addColumnDefinition{
  my $self = shift;
  my $table = shift;
  my $columnDefinition = shift;

  $self->{output}->writeMessageBegin('addColumnDefinition', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_addColumnDefinition_args();
  $args->{table} = $table;
  $args->{columnDefinition} = $columnDefinition;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_addColumnDefinition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_addColumnDefinition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "addColumnDefinition failed: unknown result";
}
sub tableList{
  my $self = shift;

    $self->send_tableList();
  return $self->recv_tableList();
}

sub send_tableList{
  my $self = shift;

  $self->{output}->writeMessageBegin('tableList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_tableList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tableList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_tableList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "tableList failed: unknown result";
}
sub tableListByCluster{
  my $self = shift;
  my $cluster = shift;

    $self->send_tableListByCluster($cluster);
  return $self->recv_tableListByCluster();
}

sub send_tableListByCluster{
  my $self = shift;
  my $cluster = shift;

  $self->{output}->writeMessageBegin('tableListByCluster', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_tableListByCluster_args();
  $args->{cluster} = $cluster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tableListByCluster{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_tableListByCluster_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "tableListByCluster failed: unknown result";
}
sub describe{
  my $self = shift;
  my $table = shift;

    $self->send_describe($table);
  return $self->recv_describe();
}

sub send_describe{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('describe', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_describe_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_describe_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "describe failed: unknown result";
}
sub schema{
  my $self = shift;
  my $table = shift;

    $self->send_schema($table);
  return $self->recv_schema();
}

sub send_schema{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('schema', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_schema_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_schema_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "schema failed: unknown result";
}
sub parseQuery{
  my $self = shift;
  my $table = shift;
  my $query = shift;

    $self->send_parseQuery($table, $query);
  return $self->recv_parseQuery();
}

sub send_parseQuery{
  my $self = shift;
  my $table = shift;
  my $query = shift;

  $self->{output}->writeMessageBegin('parseQuery', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_parseQuery_args();
  $args->{table} = $table;
  $args->{query} = $query;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_parseQuery{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_parseQuery_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "parseQuery failed: unknown result";
}
sub tableStats{
  my $self = shift;
  my $table = shift;

    $self->send_tableStats($table);
  return $self->recv_tableStats();
}

sub send_tableStats{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('tableStats', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_tableStats_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tableStats{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_tableStats_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "tableStats failed: unknown result";
}
sub optimize{
  my $self = shift;
  my $table = shift;
  my $numberOfSegmentsPerShard = shift;

    $self->send_optimize($table, $numberOfSegmentsPerShard);
  $self->recv_optimize();
}

sub send_optimize{
  my $self = shift;
  my $table = shift;
  my $numberOfSegmentsPerShard = shift;

  $self->{output}->writeMessageBegin('optimize', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_optimize_args();
  $args->{table} = $table;
  $args->{numberOfSegmentsPerShard} = $numberOfSegmentsPerShard;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_optimize{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_optimize_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub createSnapshot{
  my $self = shift;
  my $table = shift;
  my $name = shift;

    $self->send_createSnapshot($table, $name);
  $self->recv_createSnapshot();
}

sub send_createSnapshot{
  my $self = shift;
  my $table = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('createSnapshot', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_createSnapshot_args();
  $args->{table} = $table;
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createSnapshot{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_createSnapshot_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub removeSnapshot{
  my $self = shift;
  my $table = shift;
  my $name = shift;

    $self->send_removeSnapshot($table, $name);
  $self->recv_removeSnapshot();
}

sub send_removeSnapshot{
  my $self = shift;
  my $table = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('removeSnapshot', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_removeSnapshot_args();
  $args->{table} = $table;
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_removeSnapshot{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_removeSnapshot_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub listSnapshots{
  my $self = shift;
  my $table = shift;

    $self->send_listSnapshots($table);
  return $self->recv_listSnapshots();
}

sub send_listSnapshots{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('listSnapshots', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_listSnapshots_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_listSnapshots{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_listSnapshots_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "listSnapshots failed: unknown result";
}
sub setUser{
  my $self = shift;
  my $user = shift;

    $self->send_setUser($user);
}

sub send_setUser{
  my $self = shift;
  my $user = shift;

  $self->{output}->writeMessageBegin('setUser', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_setUser_args();
  $args->{user} = $user;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub query{
  my $self = shift;
  my $table = shift;
  my $blurQuery = shift;

    $self->send_query($table, $blurQuery);
  return $self->recv_query();
}

sub send_query{
  my $self = shift;
  my $table = shift;
  my $blurQuery = shift;

  $self->{output}->writeMessageBegin('query', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_query_args();
  $args->{table} = $table;
  $args->{blurQuery} = $blurQuery;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "query failed: unknown result";
}
sub fetchRow{
  my $self = shift;
  my $table = shift;
  my $selector = shift;

    $self->send_fetchRow($table, $selector);
  return $self->recv_fetchRow();
}

sub send_fetchRow{
  my $self = shift;
  my $table = shift;
  my $selector = shift;

  $self->{output}->writeMessageBegin('fetchRow', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_fetchRow_args();
  $args->{table} = $table;
  $args->{selector} = $selector;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_fetchRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_fetchRow_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "fetchRow failed: unknown result";
}
sub fetchRowBatch{
  my $self = shift;
  my $table = shift;
  my $selectors = shift;

    $self->send_fetchRowBatch($table, $selectors);
  return $self->recv_fetchRowBatch();
}

sub send_fetchRowBatch{
  my $self = shift;
  my $table = shift;
  my $selectors = shift;

  $self->{output}->writeMessageBegin('fetchRowBatch', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_fetchRowBatch_args();
  $args->{table} = $table;
  $args->{selectors} = $selectors;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_fetchRowBatch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_fetchRowBatch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "fetchRowBatch failed: unknown result";
}
sub mutate{
  my $self = shift;
  my $mutation = shift;

    $self->send_mutate($mutation);
  $self->recv_mutate();
}

sub send_mutate{
  my $self = shift;
  my $mutation = shift;

  $self->{output}->writeMessageBegin('mutate', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_mutate_args();
  $args->{mutation} = $mutation;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_mutate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub mutateBatch{
  my $self = shift;
  my $mutations = shift;

    $self->send_mutateBatch($mutations);
  $self->recv_mutateBatch();
}

sub send_mutateBatch{
  my $self = shift;
  my $mutations = shift;

  $self->{output}->writeMessageBegin('mutateBatch', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_mutateBatch_args();
  $args->{mutations} = $mutations;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateBatch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_mutateBatch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub cancelQuery{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

    $self->send_cancelQuery($table, $uuid);
  $self->recv_cancelQuery();
}

sub send_cancelQuery{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  $self->{output}->writeMessageBegin('cancelQuery', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_cancelQuery_args();
  $args->{table} = $table;
  $args->{uuid} = $uuid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancelQuery{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_cancelQuery_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub queryStatusIdList{
  my $self = shift;
  my $table = shift;

    $self->send_queryStatusIdList($table);
  return $self->recv_queryStatusIdList();
}

sub send_queryStatusIdList{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('queryStatusIdList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_queryStatusIdList_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_queryStatusIdList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_queryStatusIdList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "queryStatusIdList failed: unknown result";
}
sub queryStatusById{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

    $self->send_queryStatusById($table, $uuid);
  return $self->recv_queryStatusById();
}

sub send_queryStatusById{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  $self->{output}->writeMessageBegin('queryStatusById', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_queryStatusById_args();
  $args->{table} = $table;
  $args->{uuid} = $uuid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_queryStatusById{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_queryStatusById_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "queryStatusById failed: unknown result";
}
sub terms{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $startWith = shift;
  my $size = shift;

    $self->send_terms($table, $columnFamily, $columnName, $startWith, $size);
  return $self->recv_terms();
}

sub send_terms{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $startWith = shift;
  my $size = shift;

  $self->{output}->writeMessageBegin('terms', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_terms_args();
  $args->{table} = $table;
  $args->{columnFamily} = $columnFamily;
  $args->{columnName} = $columnName;
  $args->{startWith} = $startWith;
  $args->{size} = $size;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_terms{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_terms_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "terms failed: unknown result";
}
sub recordFrequency{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $value = shift;

    $self->send_recordFrequency($table, $columnFamily, $columnName, $value);
  return $self->recv_recordFrequency();
}

sub send_recordFrequency{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $value = shift;

  $self->{output}->writeMessageBegin('recordFrequency', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_recordFrequency_args();
  $args->{table} = $table;
  $args->{columnFamily} = $columnFamily;
  $args->{columnName} = $columnName;
  $args->{value} = $value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_recordFrequency{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_recordFrequency_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "recordFrequency failed: unknown result";
}
sub shardClusterList{
  my $self = shift;

    $self->send_shardClusterList();
  return $self->recv_shardClusterList();
}

sub send_shardClusterList{
  my $self = shift;

  $self->{output}->writeMessageBegin('shardClusterList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardClusterList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardClusterList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardClusterList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardClusterList failed: unknown result";
}
sub shardServerList{
  my $self = shift;
  my $cluster = shift;

    $self->send_shardServerList($cluster);
  return $self->recv_shardServerList();
}

sub send_shardServerList{
  my $self = shift;
  my $cluster = shift;

  $self->{output}->writeMessageBegin('shardServerList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardServerList_args();
  $args->{cluster} = $cluster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardServerList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardServerList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardServerList failed: unknown result";
}
sub controllerServerList{
  my $self = shift;

    $self->send_controllerServerList();
  return $self->recv_controllerServerList();
}

sub send_controllerServerList{
  my $self = shift;

  $self->{output}->writeMessageBegin('controllerServerList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_controllerServerList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_controllerServerList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_controllerServerList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "controllerServerList failed: unknown result";
}
sub shardServerLayout{
  my $self = shift;
  my $table = shift;

    $self->send_shardServerLayout($table);
  return $self->recv_shardServerLayout();
}

sub send_shardServerLayout{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('shardServerLayout', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardServerLayout_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardServerLayout{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardServerLayout_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardServerLayout failed: unknown result";
}
sub shardServerLayoutState{
  my $self = shift;
  my $table = shift;

    $self->send_shardServerLayoutState($table);
  return $self->recv_shardServerLayoutState();
}

sub send_shardServerLayoutState{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('shardServerLayoutState', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardServerLayoutState_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardServerLayoutState{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardServerLayoutState_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardServerLayoutState failed: unknown result";
}
sub isInSafeMode{
  my $self = shift;
  my $cluster = shift;

    $self->send_isInSafeMode($cluster);
  return $self->recv_isInSafeMode();
}

sub send_isInSafeMode{
  my $self = shift;
  my $cluster = shift;

  $self->{output}->writeMessageBegin('isInSafeMode', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_isInSafeMode_args();
  $args->{cluster} = $cluster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_isInSafeMode{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_isInSafeMode_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "isInSafeMode failed: unknown result";
}
sub configuration{
  my $self = shift;

    $self->send_configuration();
  return $self->recv_configuration();
}

sub send_configuration{
  my $self = shift;

  $self->{output}->writeMessageBegin('configuration', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_configuration_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_configuration{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_configuration_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "configuration failed: unknown result";
}
sub metrics{
  my $self = shift;
  my $metrics = shift;

    $self->send_metrics($metrics);
  return $self->recv_metrics();
}

sub send_metrics{
  my $self = shift;
  my $metrics = shift;

  $self->{output}->writeMessageBegin('metrics', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_metrics_args();
  $args->{metrics} = $metrics;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_metrics{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_metrics_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "metrics failed: unknown result";
}
sub startTrace{
  my $self = shift;
  my $traceId = shift;

    $self->send_startTrace($traceId);
}

sub send_startTrace{
  my $self = shift;
  my $traceId = shift;

  $self->{output}->writeMessageBegin('startTrace', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_startTrace_args();
  $args->{traceId} = $traceId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
package Blur::BlurProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_createTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_createTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_createTable_result();
    eval {
      $self->{handler}->createTable($args->tableDescriptor);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('createTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_enableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_enableTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_enableTable_result();
    eval {
      $self->{handler}->enableTable($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('enableTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_disableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_disableTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_disableTable_result();
    eval {
      $self->{handler}->disableTable($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('disableTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_removeTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_removeTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_removeTable_result();
    eval {
      $self->{handler}->removeTable($args->table, $args->deleteIndexFiles);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('removeTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_addColumnDefinition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_addColumnDefinition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_addColumnDefinition_result();
    eval {
      $result->{success} = $self->{handler}->addColumnDefinition($args->table, $args->columnDefinition);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('addColumnDefinition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tableList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_tableList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_tableList_result();
    eval {
      $result->{success} = $self->{handler}->tableList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('tableList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tableListByCluster {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_tableListByCluster_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_tableListByCluster_result();
    eval {
      $result->{success} = $self->{handler}->tableListByCluster($args->cluster);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('tableListByCluster', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_describe_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_describe_result();
    eval {
      $result->{success} = $self->{handler}->describe($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('describe', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_schema_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_schema_result();
    eval {
      $result->{success} = $self->{handler}->schema($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('schema', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_parseQuery {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_parseQuery_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_parseQuery_result();
    eval {
      $result->{success} = $self->{handler}->parseQuery($args->table, $args->query);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('parseQuery', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tableStats {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_tableStats_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_tableStats_result();
    eval {
      $result->{success} = $self->{handler}->tableStats($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('tableStats', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_optimize {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_optimize_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_optimize_result();
    eval {
      $self->{handler}->optimize($args->table, $args->numberOfSegmentsPerShard);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('optimize', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createSnapshot {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_createSnapshot_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_createSnapshot_result();
    eval {
      $self->{handler}->createSnapshot($args->table, $args->name);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('createSnapshot', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_removeSnapshot {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_removeSnapshot_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_removeSnapshot_result();
    eval {
      $self->{handler}->removeSnapshot($args->table, $args->name);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('removeSnapshot', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_listSnapshots {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_listSnapshots_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_listSnapshots_result();
    eval {
      $result->{success} = $self->{handler}->listSnapshots($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('listSnapshots', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_setUser {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_setUser_args();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->setUser($args->user);
    return;
}
sub process_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_query_result();
    eval {
      $result->{success} = $self->{handler}->query($args->table, $args->blurQuery);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_fetchRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_fetchRow_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_fetchRow_result();
    eval {
      $result->{success} = $self->{handler}->fetchRow($args->table, $args->selector);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('fetchRow', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_fetchRowBatch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_fetchRowBatch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_fetchRowBatch_result();
    eval {
      $result->{success} = $self->{handler}->fetchRowBatch($args->table, $args->selectors);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('fetchRowBatch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_mutate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_mutate_result();
    eval {
      $self->{handler}->mutate($args->mutation);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('mutate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateBatch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_mutateBatch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_mutateBatch_result();
    eval {
      $self->{handler}->mutateBatch($args->mutations);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('mutateBatch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancelQuery {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_cancelQuery_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_cancelQuery_result();
    eval {
      $self->{handler}->cancelQuery($args->table, $args->uuid);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('cancelQuery', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_queryStatusIdList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_queryStatusIdList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_queryStatusIdList_result();
    eval {
      $result->{success} = $self->{handler}->queryStatusIdList($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('queryStatusIdList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_queryStatusById {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_queryStatusById_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_queryStatusById_result();
    eval {
      $result->{success} = $self->{handler}->queryStatusById($args->table, $args->uuid);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('queryStatusById', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_terms {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_terms_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_terms_result();
    eval {
      $result->{success} = $self->{handler}->terms($args->table, $args->columnFamily, $args->columnName, $args->startWith, $args->size);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('terms', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_recordFrequency {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_recordFrequency_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_recordFrequency_result();
    eval {
      $result->{success} = $self->{handler}->recordFrequency($args->table, $args->columnFamily, $args->columnName, $args->value);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('recordFrequency', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardClusterList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardClusterList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardClusterList_result();
    eval {
      $result->{success} = $self->{handler}->shardClusterList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardClusterList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardServerList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardServerList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardServerList_result();
    eval {
      $result->{success} = $self->{handler}->shardServerList($args->cluster);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardServerList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_controllerServerList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_controllerServerList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_controllerServerList_result();
    eval {
      $result->{success} = $self->{handler}->controllerServerList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('controllerServerList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardServerLayout {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardServerLayout_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardServerLayout_result();
    eval {
      $result->{success} = $self->{handler}->shardServerLayout($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardServerLayout', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardServerLayoutState {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardServerLayoutState_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardServerLayoutState_result();
    eval {
      $result->{success} = $self->{handler}->shardServerLayoutState($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardServerLayoutState', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_isInSafeMode {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_isInSafeMode_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_isInSafeMode_result();
    eval {
      $result->{success} = $self->{handler}->isInSafeMode($args->cluster);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('isInSafeMode', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_configuration {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_configuration_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_configuration_result();
    eval {
      $result->{success} = $self->{handler}->configuration();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('configuration', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_metrics {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_metrics_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_metrics_result();
    eval {
      $result->{success} = $self->{handler}->metrics($args->metrics);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('metrics', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_startTrace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_startTrace_args();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->startTrace($args->traceId);
    return;
}
1;
